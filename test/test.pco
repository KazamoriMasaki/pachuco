;;; Tests

(defmacro (assert-result expr expect)
  (quasiquote
    (begin
      (define res (unquote expr))
      (define expected (unquote expect))
      (unless (equal? res expected)
        (error "Evaluation of ~S gave ~S, expected ~S" (quote (unquote expr))
               res expected)))))

(define (tests)
  ;; This test assumes the intended behaviour compiler behaviour.  The
  ;; interpreter does something different, in the name of simplicity.
  ;; What a lanuage spec might have to say about this is uncertain at
  ;; this point.
  (when-compiling
    (begin
      (define x 0)
      (begin
        (define x x)
        (assert-result x unspecified))))

  (assert-result (function? ()) false)
  (assert-result (function? (lambda ())) true)

  (assert-result (and) true)
  (assert-result (and true) true)
  (assert-result (and false) false)
  (assert-result (and true false) false)
  (assert-result (and false true) false)
  (assert-result (and true true true) true)

  (assert-result (or) false)
  (assert-result (or true) true)
  (assert-result (or false) false)

  (assert-result (length '(1 2 3)) 3)

  (begin
    (defmacro (foo) 1)
    (assert-result (foo) 1))
  (begin
    (defmacro foo 2)
    (assert-result foo 2))
  (begin
    (define foo 3)
    (assert-result foo 3))

  (begin
    (define x (cons 1 2))
    (assert-result (rplaca x 3) '(3 . 2))
    (assert-result (rplacd x 4) '(3 . 4)))

  (assert-result (list 1 2 3) '(1 2 3))
  (assert-result (append '(1 2) '(3 4)) '(1 2 3 4))

  (begin
    (define ht (make-hashtable string-hash string-equal?))
    (assert-result (hashtable-ref ht "foo") false)
    (hashtable-set! ht "foo" "bar")
    (assert-result (hashtable-ref ht "foo") "bar")
    (hashtable-set! ht "foo" "baz")
    (assert-result (hashtable-ref ht "foo") "baz")

    (define l ())
    (for-hashtable (k v ht)
      (set! l (acons k v l)))
    (assert-result l '(("foo" . "baz"))))

  (assert-result (string-equal? (symbol-name 'foo) "foo") true)
  (assert-result (eq? (intern "foo") 'foo) true)
  (assert-result (symbol-name (intern "bar")) "bar")

  (assert-result (1+ 1) 2)
  (assert-result (1- 1) 0)

  (assert-result (truncate -5 2) -2)

  (begin
    (defmacro (ash-tests)
      '(begin
         (assert-result (ashx 48 2) 192)
         (assert-result (ashx 48 -2) 12)
         (assert-result (ashx -5 -1) -3)

         (assert-result (ashx 1 1000) 0)
         (assert-result (ashx 1 -1000) 0)
         (assert-result (ashx -1 -1000) -1)

         (when-compiling
           (if (= (compiler-constant value-size) 4)
               (begin
                (assert-result (ashx 1 32) 0)
                (assert-result (ashx -1 -32) -1))
               (begin
                (assert-result (ashx 1 64) 0)
                (assert-result (ashx -1 -64) -1))))))

    ;; Test the immediate shift forms of ash
    (begin
      (defmacro (ashx n shift) (list 'ash n shift))
      (ash-tests))

    ;; Test the variable shift forms of ash
    (begin
      (defmacro (ashx n shift) (quasiquote (begin
                                             (define sh (unquote shift))
                                             (ash (unquote n) sh))))
      (ash-tests)))

  (assert-result (copy-tree '((1 . 2) 3)) '((1 . 2) 3))

  (assert-result (nconc ()) ())
  (assert-result (nconc (copy-list '(1 2)) (copy-list '(3 4))) '(1 2 3 4))
  (assert-result (nconc () (copy-list '(1 2)) () (copy-list '(3 4)))
                 '(1 2 3 4))

  (assert-result (remove 1 '(0 1 2 1)) '(0 2))
  (assert-result (delete 1 (copy-list '(0 1 2 1))) '(0 2))
  (assert-result (sort '(3 6 4 8 7 5 2 9 1 0) <) '(0 1 2 3 4 5 6 7 8 9))
  (assert-result (sort '(1 2 1 2) <) '(1 1 2 2))
  (assert-result (reverse '(1 2 3)) '(3 2 1))

  (assert-result (mapfor (x '(1 2 3)) (1+ x)) '(2 3 4))
  (assert-result (mapfor (x ()) (error "Whoa!")) ())
  (assert-result (mapfor (x '(a)) x) '(a))

  (assert-result (nmapfor (x (list 1 2 3)) (1+ x)) '(2 3 4))

  (assert-result (findfor (x '(1 2 3)) (> x 1)) 2)
  (assert-result (findfor (x ()) (error "Whoa!")) false)
  (assert-result (findfor (x '(1)) (> x 1)) false)

  (assert-result (filterfor (x '(0 1 2 3 4 5)) (= 0 (rem x 2)))
                 '(0 2 4))
  (assert-result (nfilterfor (x (list 0 1 2 3 4 5)) (= 0 (rem x 2)))
                 '(0 2 4))

  (assert-result (sublist '(1 2 3) 1) '(2 3))
  (assert-result (sublist '(1 2 3 4) 1 3) '(2 3))

  (begin
    (define x '(1 2))

    (assert-result (quasiquote (a b c)) '(a b c))
    (assert-result (quasiquote ((unquote x) b c)) '((1 2) b c))
    (assert-result (quasiquote (a (unquote x) c)) '(a (1 2) c))
    (assert-result (quasiquote (a b (unquote x))) '(a b (1 2)))

    (assert-result (quasiquote ((unquote-splicing x) b c)) '(1 2 b c))
    (assert-result (quasiquote (a (unquote-splicing x) c)) '(a 1 2 c))
    (assert-result (quasiquote (a b (unquote-splicing x))) '(a b 1 2)))

  (begin
    (defmacro (assert-applied-result expr expect)
      (quasiquote (begin
                    (assert-result (unquote expr) (unquote expect))
                    (assert-result (apply (unquote (car expr))
                                          (quote (unquote (cdr expr))))
                                   (unquote expect)))))
    (assert-applied-result (+) 0)
    (assert-applied-result (+ 1) 1)
    (assert-applied-result (+ 1 2) 3)
    (assert-applied-result (+ 1 2 3) 6)

    (assert-applied-result (*) 1)
    (assert-applied-result (* 1) 1)
    (assert-applied-result (* 1 2) 2)
    (assert-applied-result (* 1 2 3) 6)

    (assert-applied-result (- 1) -1)
    (assert-applied-result (- 1 2) -1)
    (assert-applied-result (- 1 2 3) -4)

    (assert-applied-result (list 1 2 3) '(1 2 3)))

  (begin
    (define (fac n)
        (if (< n 2) 1
            (* n (fac (- n 1)))))
    (assert-result (fac 6) 720))

  ;; Test string ref, string copy
  (assert-result (string-equal? "foo" "foo") true)
  (assert-result (string-equal? "foo" "bar") false)

  (assert-result (string< "aaa" "aab") true)
  (assert-result (string< "aab" "aaa") false)
  (assert-result (string< "aaa" "aaa") false)
  (assert-result (string< "aaa" "aaaa") true)
  (assert-result (string< "aaaa" "aaa") false)

  (assert-result (substring "Hello" 1 3) "ell")
  (assert-result (string-search "banana" "an" 0) 1)
  (assert-result (string-search "banana" "an" 2) 3)
  (assert-result (string-replace "banana" "an" "rane") "braneranea")
  (assert-result (not (character? #\x)) false)

  ;; Test overlapping string and vector copies
  (assert-result (begin
                   (define s (format "foobar"))
                   (string-copy s 1 s 2 3)
                   s)
                 "fooobr")
  (assert-result (begin
                   (define s (format "foobar"))
                   (string-copy s 2 s 1 3)
                   s)
                 "fobaar")
  (assert-result (begin
                   (define v (vector 1 2 3 4 5 6))
                   (vector-copy v 1 v 2 3)
                   v)
                 (vector 1 2 2 3 4 6))
  (assert-result (begin
                   (define v (vector 1 2 3 4 5 6))
                   (vector-copy v 2 v 1 3)
                   v)
                 (vector 1 3 4 5 5 6))

  (assert-result (vector-equal? (vector 1 2 3)
                                (make-vector-from-list '(1 2 3)))
                 true)

  (begin
    (define (assert-uniform-format a expect)
      (assert-result (format "~S" a) expect)
      (assert-result (format "~A" a) expect))

    (define (assert-non-uniform-format a sexpect aexpect)
      (assert-result (format "~S" a) sexpect)
      (assert-result (format "~A" a) aexpect))

    (assert-uniform-format 0 "0")
    (assert-uniform-format 242143 "242143")
    (assert-uniform-format -1 "-1")
    (assert-uniform-format () "()")
    (assert-uniform-format 'foo "foo")
    (assert-uniform-format '(a b) "(a b)")
    (assert-uniform-format '(a . b) "(a . b)")
    (assert-uniform-format (lambda ()) "#<function>")

    (assert-non-uniform-format "Hello" "\"Hello\"" "Hello")
    (assert-non-uniform-format '("Hello" "there") "(\"Hello\" \"there\")"
                               "(Hello there)")

    (assert-result (format "~%") "
"))

  (assert-result (apply append '((1 2) (3 4)) '((5 6) (7 8)))
                 '((1 2) (3 4) 5 6 7 8))

  (begin
    (define istr (make-string-istream "ab"))
    (assert-result (peek-character istr 0) #\a)
    (assert-result (peek-character istr 1) #\b)
    (assert-result (read-character istr false) #\a)
    (assert-result (peek-character istr 0) #\b)
    (assert-result (peek-character istr 1) false)
    (istream-consume istr 1)
    (assert-result (read-character istr true) false))

  (begin
    (assert-result (read-integer (make-string-istream "1fF") 16) 511)
    (define istr (make-string-istream "123 "))
    (assert-result (read-integer istr 10) 123)
    (assert-result (peek-character istr 0) #\Space))

  (begin
    (define istr (make-string-istream "hello world (etc (etc)  )etc(etc)"))
    (assert-result (read istr) 'hello)
    (assert-result (read istr) 'world)
    (assert-result (read istr) '(etc (etc)))
    (assert-result (read istr) 'etc)
    (assert-result (read istr) '(etc))

    (assert-result (read (make-string-istream " ") true) true)

    (define (assert-read str expect)
      (assert-result (read (make-string-istream str)) expect))

    (assert-read "(100)" '(100))
    (assert-read "-100" -100)
    (assert-read "1-" '1-)
    (assert-read "#x1Ff" 511)
    (assert-read "#x-1Ff" -511)
    (assert-read "#b101" 5)

    (assert-read "(x . y)" '(x . y))
    (assert-read "(x .y)" '(x .y))
    (assert-read "(x .(y))" '(x y))
    (assert-read "(x .())" '(x))
    (assert-read "((x . ()) y)" '((x) y))

    (assert-read "'(x)" '(quote (x)))

    (assert-read "\"hello\"" "hello")
    (assert-read "\"\\\" \\\\ \\\"\"" "\" \\ \"")

    (assert-read "#\\x" #\x)
    (assert-read "#\\\"" #\")
    (assert-read "#\\Space" #\Space)
    (assert-read "#\\Newline" #\Newline)

    (assert-read "true" true)
    (assert-read "false" false)
    (assert-read "unspecified" unspecified)

    (assert-read "(x;comment
y)" '(x y))
    (assert-read "(x ;comment
)" '(x)))

  (with-open-file-for-reading (f "test/testfile")
    (assert-result (read f) '("hello" world))
    (assert-result (read f false) false))

  ;; check that body forms at the end of bodies are evaluated correctly
  (assert-result (begin (define x true) (define y x)) true)
  (assert-result (begin
                   (define x true)
                   (definitions (set! x false) (define y x)))
                 false)
  (assert-result (begin
                   (define (f) (set! f false) (define x f))
                   (f))
                 false))

(define (main)
  (tests)
  (formout stdout "Tests done~%"))
