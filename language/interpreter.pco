;;; Interpreter

;;; An interpreter environment is a list of alists, each mapping

(define interpreter-builtin-forms (make-symboltable))

(defmacro (define-interpreter-builtin-form keyword . body)
  (quasiquote
    (symboltable-set! interpreter-builtin-forms '(unquote keyword)
                      (lambda (keyword args env in-body)
                        (unquote-splicing body)))))

(define interpreter-builtin-vars (make-symboltable))

(defmacro (define-interpreter-builtin-var name val)
  (quasiquote
    (symboltable-set! interpreter-builtin-vars
                      '(unquote name) (cons (unquote val) ()))))

(define (make-initial-interpreter-env)
  (list (make-symboltable) interpreter-builtin-vars))

(define (eval-form-aux form env in-body)
  (cond ((pair? form)
         (let* ((keyword (car form))
                (args (cdr form))
                (builtin (and (symbol? keyword)
                              (symboltable-ref interpreter-builtin-forms
                                               keyword))))
           (if builtin
               (funcall builtin keyword args env in-body)
               (eval-call form env))))
        ((symbol? form)
         (let* ((cell (symboltable-list-ref env form)))
           (unless cell (error "unbound variable ~S" form))
           (car cell)))
        (true form)))

(define (eval-form form env)
  (eval-form-aux form env false))

(define (eval-body-form form env)
  (eval-form-aux form env true))

(define (eval-body forms env)
  (if (null? forms)
      unspecified
      (eval-body-aux forms env)))

(define (eval-body-aux forms env)
  (if (null? (cdr forms))
      (eval-form-aux (car forms) env true)
      (begin
        (eval-form-aux (car forms) env true)
        (eval-body-aux (cdr forms) env))))

(define (add-lambda-vars vars formals actuals)
  (cond ((null? formals)
         (if (null? actuals) ()
             (error "surplus arguments ~S" actuals)))
        ((symbol? formals)
         (symboltable-set! vars formals (cons actuals ())))
        (true
         (when (null? actuals) (error "insufficient arguments"))
         (symboltable-set! vars (car formals) (cons (car actuals) ()))
         (add-lambda-vars vars (cdr formals) (cdr actuals)))))

(define-interpreter-builtin-form lambda
  (lambda (actuals)
    (let* ((vars (make-symboltable)))
      (add-lambda-vars vars (car args) actuals)
      (eval-body (cdr args) (cons vars env)))))

(define (eval-forms forms env)
  (mapfor (form forms) (eval-form-aux form env false)))

(define (eval-call form env)
  (let* ((evaled-subforms (eval-forms form env)))
    (funcall (car evaled-subforms) (cdr evaled-subforms))))

(define-interpreter-builtin-form begin
  (eval-body args (cons false env)))

(define-interpreter-builtin-form definitions
  (unless in-body (error "definitions not in body"))
  (eval-body args env))

(define-interpreter-builtin-form define
  (unless in-body (error "define not in body"))
  (let* ((var (first args))
         (val (if (null? (cdr args)) unspecified
                  (eval-form-aux (second args) env false)))
         (st (car env)))
    (unless (symbol? var) (error "bad variable name ~S" var))
    (unless st (rplaca env (set! st (make-symboltable))))
    (when (symboltable-ref st var) (error "variable ~S already bound" var))
    (symboltable-set! st var (cons val ()))
    val))

(define-interpreter-builtin-form set!
  (let* ((val (eval-form-aux (second args) env false))
         (cell (symboltable-list-ref env (first args))))
    (unless cell (error "unbound variable ~S" (first args)))
    (rplaca cell val)
    val))

(define-interpreter-builtin-form if
  (if (subject-language-boolean (eval-form-aux (first args) env false))
      (eval-form-aux (second args) env false)
      (if (null? (cddr args))
          'unspecified
          (eval-form-aux (third args) env false))))

(define-interpreter-builtin-form quote
  (first args))

(defmacro (define-interpreter-builtin-op op . body)
  (quasiquote
    (define-interpreter-builtin-form (unquote op)
      (let* ((evaled-args (eval-forms args env)))
        (unquote (cond ((null? body)
                        (quasiquote
                          (apply (function (unquote op)) evaled-args)))
                       ((null? (cdr body))
                        (quasiquote
                          (apply (function (unquote (car body))) evaled-args)))
                       (true
                        (quasiquote
                          (bind (unquote (car body)) evaled-args
                                (unquote-splicing (cdr body)))))))))))

(defmacro (define-interpreter-builtin-boolean-op op)
  (quasiquote
    (define-interpreter-builtin-form (unquote op)
      (if (apply (function (unquote op)) (eval-forms args env))
         'true 'false))))

(define-interpreter-builtin-op error-halt)

(define-interpreter-builtin-boolean-op eq?)
(define-interpreter-builtin-boolean-op function?)

(define-interpreter-builtin-boolean-op symbol?)
(define-interpreter-builtin-op gensym)
(define-interpreter-builtin-op symbol-name (sym)
  (subject-language-symbol-name sym))
(define-interpreter-builtin-op symbol-id)
(define-interpreter-builtin-op intern (str)
  (subject-language-intern str))

(define-interpreter-builtin-boolean-op pair?)
(define-interpreter-builtin-op car)
(define-interpreter-builtin-op cdr)
(define-interpreter-builtin-op cons)
(define-interpreter-builtin-op rplaca)
(define-interpreter-builtin-op rplacd)

(define-interpreter-builtin-boolean-op number?)
(define-interpreter-builtin-boolean-op <)
(define-interpreter-builtin-boolean-op <=)
(define-interpreter-builtin-boolean-op >)
(define-interpreter-builtin-boolean-op >=)
(define-interpreter-builtin-boolean-op =)
(define-interpreter-builtin-boolean-op /=)
(define-interpreter-builtin-op +)
(define-interpreter-builtin-op -)
(define-interpreter-builtin-op *)
(define-interpreter-builtin-op rem)
(define-interpreter-builtin-op truncate)
(define-interpreter-builtin-op ash)
(define-interpreter-builtin-op logand)
(define-interpreter-builtin-op logior)
(define-interpreter-builtin-op logxor)

(define-interpreter-builtin-boolean-op character?)
(define-interpreter-builtin-op character-code)
(define-interpreter-builtin-op code-character)

(define-interpreter-builtin-boolean-op string?)
(define-interpreter-builtin-op make-string)
(define-interpreter-builtin-op string-length)
(define-interpreter-builtin-op raw-string-ref string-ref)
(define-interpreter-builtin-op raw-string-set! string-set!)
(define-interpreter-builtin-op raw-string-copy string-copy)

(define-interpreter-builtin-boolean-op vector?)
(define-interpreter-builtin-op make-vector)
(define-interpreter-builtin-op vector-length)
(define-interpreter-builtin-op raw-vector-ref vector-ref)
(define-interpreter-builtin-op raw-vector-set! vector-set!)
(define-interpreter-builtin-op raw-vector-copy vector-copy)

(define-interpreter-builtin-op raw-write-substring)
(define-interpreter-builtin-var raw-stdout raw-stdout)
(define-interpreter-builtin-var raw-stderr raw-stderr)
(define-interpreter-builtin-op raw-read-substring)
(define-interpreter-builtin-var raw-stdin raw-stdin)
(define-interpreter-builtin-op open-file-for-reading)
(define-interpreter-builtin-op close-file)

(define-interpreter-builtin-op apply (func . args)
  (funcall func (apply (function list*) args)))
