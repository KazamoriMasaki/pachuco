;;; x86 bitness-independent code generation

;;; Assembly bits

(defconstant value-insn-size-suffix (insn-size-suffix value-scale))

(define (emit-align cg scale)
  (emit cg ".align ~D" (ash 1 scale)))

;;; Registers and address modes
;;;
;;; - immediates are simply numbers or strings (representing assembler
;;; labels)
;;;
;;; - registers a vector of strings, giving the name of the register
;;; for the various scales
;;;
;;; - a memory reference a list of the form (offset regs...)

(define (immediate? x) (or (number? x) (string? x)))
(define (register? x) (vector? x))
(define (mem? x) (pair? x))

(defmarco (register-operand reg scale)
  (list 'register-variant reg scale))

(define (mem1 x)
  (cond ((register? x) (list 0 x))
        ((immediate? x) (list x))
        ((mem? x) x)
        (true (error "bad operand ~S" x))))

(define (mem-list args)
  (let* ((n 0) (regs ()))
    (dolist (arg args)
      (cond ((number? arg)
             (set! n (+ n (* value-size arg))))
            ((string? arg)
             (unless (eq? n 0) (error "adding label to number"))
             (set! n arg))
            ((register? arg)
             (set! regs (nconc regs (list arg))))
            ((pair? arg)
             (set! n (+ n (car arg)))
             (set! regs (append regs (copy-list (cdr arg)))))
            (true
             (error "bad operand ~S" arg))))

    (when (> (length regs) 2) (error "too many registers"))
    (cons n regs)))

(define (mem . args)
  (mem-list args))

(define (mem1+ m n)
  (let* ((memm (mem m)))
    (cons (+ (car memm) n) (cdr memm))))

(define (tagged-mem tag . args)
  (let* ((m (mem-list args)))
    (cons (- (car m) tag) (cdr m))))

(define (mem-offset m offset)
  (set! m (mem1 m))
  (if (register? offset)
      (list* (car m) offset (cdr m))
      (cons (+ (car m) offset) (cdr m))))

(define (insn-operand x scale)
  (cond ((immediate? x) (format~ false "$~A" x))
        ((vector? x) (register-operand x scale))
        ((pair? x)
         (cond ((null? (cdr x)) (indirect-operand (car x)))
               ((null? (cddr x))
                (format~ false "~A(~A)" (if (eq? 0 (car x)) "" (car x))
                         (register-operand (second x) value-scale)))
               (true
                (format~ false "~A(~A,~A)" (if (eq? 0 (car x)) "" (car x))
                         (register-operand (second x) value-scale)
                         (register-operand (third x) value-scale)))))
        (true (error "strange operand ~S" x))))

(define (value-sized operand)
  (insn-operand operand value-scale))

(define (operand-using-reg? o r)
  (cond ((register? o) (eq? o r))
        ((mem? o) (member? r (cdr o)))
        (true false)))

;;; Operator argument constraints

(define (reg-mem-operand-constraint cg operand reg)
  (if (or (immediate? operand)
          (and (register? operand) (not (eq? operand reg))))
      (begin
        (emit-mov cg operand reg)
        reg)
      operand))

(define (reg-mem-imm-operand-constraint cg operand reg)
  (if (and (register? operand) (not (eq? operand reg)))
      (begin
        (emit-mov cg operand reg)
        reg)
      operand))

(define (reg-imm-operand-constraint cg operand reg)
  (if (or (mem? operand)
          (and (register? operand) (not (eq? operand reg))))
      (begin
        (emit-mov cg operand reg)
        reg)
      operand))

;;; Condition codes

(define (negate-cc cc)
  (if (eq? (string-ref cc 0) #\n)
      (substring cc 1 (1- (string-length cc)))
      (string-concat "n" cc)))

;;; Instructions

(defmarco (define-insn-2 name insn)
  (quasiquote
    (define ((unquote name) cg src dest . scale)
      (emit-insn-2 cg (unquote insn) src dest scale))))

(define (emit-insn-2 cg insn src dest scale)
  (set! scale (if (null? scale) value-scale (car scale)))
  (emit cg "~A~A ~A, ~A" insn (insn-size-suffix scale)
        (insn-operand src scale) (insn-operand dest scale)))

(define-insn-2 emit-lea "lea")
(define-insn-2 emit-add "add")
(define-insn-2 emit-sub "sub")
(define-insn-2 emit-imul "imul")
(define-insn-2 emit-and "and")
(define-insn-2 emit-or "or")
(define-insn-2 emit-xor "xor")
(define-insn-2 emit-cmp "cmp")
(define-insn-2 emit-test "test")
(define-insn-2 emit-shl "shl")
(define-insn-2 emit-sar "sar")

(define (emit-clear cg reg . scale)
  (set! scale (if (null? scale) value-scale (car scale)))
  (emit-xor cg reg reg (min 2 scale)))

(define (emit-mov cg src dest . scale)
  (cond ((and (eq? src 0) (register? dest))
         (emit-clear cg dest))
        ((and (number? src) (register? dest) (> src 0) (< src 1000000))
         (emit-movzx cg src dest
                     (min 2 (if (null? scale) value-scale (car scale)))))
        (true
         (emit-insn-2 cg "mov" src dest scale))))

(define (emit-movzx-32 cg src dest src-scale dest-scale)
  (emit cg "mov~A ~A,~A"
        (elt (elt '(("b")
                    ("zbw" "w")
                    ("zbl" "zwl" "l")) dest-scale) src-scale)
        (insn-operand src src-scale)
        (insn-operand dest dest-scale)))

(define (emit-push cg reg)
  (emit cg "push~A ~A" value-insn-size-suffix (value-sized reg)))

(define (emit-pop cg reg)
  (emit cg "pop~A ~A" value-insn-size-suffix (value-sized reg)))

(define (emit-set cg cc reg)
  (emit cg "set~A ~A" cc (insn-operand reg 0)))

(defmarco (define-insn-1 name insn)
  (quasiquote
    (define ((unquote name) cg oper . scale)
      (emit-insn-1 cg (unquote insn) oper
                   (if (null? scale) value-scale (car scale))))))

(define (emit-insn-1 cg insn oper scale)
  (emit cg "~A~A ~A" insn (insn-size-suffix scale) (insn-operand oper scale)))

(define-insn-1 emit-neg "neg")
(define-insn-1 emit-not "not")
(define-insn-1 emit-idiv "idiv")

(define (emit-ret cg imm)
  (if (= 0 imm)
      (emit cg "ret")
      (emit cg "ret $~D" imm)))

(defmarco (define-insn-0 name insn)
  (quasiquote
    (define ((unquote name) cg . scale)
      (emit cg "~A~A" (unquote insn)
            (insn-size-suffix (if (null? scale) value-scale (car scale)))))))

(define-insn-0 emit-rep-movs "rep ; movs")
(define-insn-0 emit-pushf "pushf")
(define-insn-0 emit-popf "popf")

(define (emit-scale-number cg scale oper)
  (cond ((= scale number-tag-bits)
         oper)
        ((number? oper)
         (ash oper (- scale number-tag-bits)))
        ((< scale number-tag-bits)
         (let* ((shift (- number-tag-bits scale)))
           (if (register? oper)
               (begin (emit-sar cg shift oper) oper)
               (format~ true "~A>>~A" oper shift))))
        (true
         (let* ((shift (- scale number-tag-bits)))
           (if (register? oper)
               (begin (emit-shl cg shift oper) oper)
               (format~ true "~A<<~A" oper shift))))))

(define (emit-branch cg cc label)
  (emit-without-flushing "j~A ~A" cc label))

(define (emit-jump cg label)
  (emit-without-flushing "jmp ~A" label))

(define (emit-mov-maybe cg src dst)
  (unless (eq? src dst) (emit-mov cg src dst)))

(define (emit-branch-on-operand cg oper out-frame-base tlabel flabel)
  (emit-cmp cg false-representation oper)
  (emit-smart-branch cg "ne" out-frame-base tlabel flabel))

(define (emit-prepare-convert-cc-value cg reg)
  (emit-clear cg reg))

(define (emit-convert-cc-value cg cc reg)
  ;; this embeds special-tag and the representations of false and true
  (emit-set cg cc reg)
  (emit-shl cg special-tag-bits reg 0)
  (emit-or cg special-tag reg 0))

(defmarco (define-tag-check name tag tag-bits)
  (quasiquote
    (define-cc-operator ((unquote name) val) ()
      ;; just check the low-order byte
      (emit-and cg (low-bits-mask (unquote tag-bits)) val 0)
      (emit-cmp cg (unquote tag) val 0)
      "e")))

;;; Heap allocation

(define (register-bitset regs)
  (reduce~ (register-bit (car regs)) (cdr regs)
           (lambda (bits reg) (logior bits (register-bit reg)))))

(define (emit-alloc cg tag-bits size allocreg spare-regs . scale)
  (let* ((again-label (gen-label))
         (exhausted-label (gen-label)))
    (flush-labels-and-jumps cg)
    (emit-raw-label cg again-label)
    (emit-mov cg (mem "heap_alloc") allocreg)
    (emit-sub cg size allocreg)
    (set! scale (if (null? scale) value-scale (car scale)))
    (unless (= tag-bits scale) (emit-and cg (- (ash 1 tag-bits)) allocreg))
    (emit-cmp cg (mem "heap_threshold") allocreg)
    (emit-branch cg "be" exhausted-label)
    (emit-mov cg allocreg (mem "heap_alloc"))

    (codegen-push-out-of-line cg
      (lambda ()
        (emit-raw-label cg exhausted-label)
        (emit-mov cg (register-bitset (cons allocreg spare-regs)) %closure)
        (emit cg "call heap_exhausted")
        (emit-restore-%closure cg)
        (emit-jump cg again-label)))))

(define gc-label (make-label-for 'gc function-label-prefix))

(define (codegen-heap-exhausted cg)
  (labels ((for-live-registers (regs op)
             (dolist (reg regs)
               (let* ((l (gen-label)))
                 (emit-test cg (register-bit reg) %closure)
                 (emit-branch cg "nz" l)
                 (funcall op cg reg)
                 (emit-raw-label cg l)))))
    (emit cg ".text")
    (emit cg ".globl heap_exhausted")
    (emit cg "heap_exhausted:")
    
    ;; Push live registers onto the stack, guided by the bitset in
    ;; %closure.  This preserves their values, and also means that
    ;; they get treated as part of the root set by the GC.
    (for-live-registers general-registers (function emit-push))
    
    ;; We need to save the live reg bitset from %closure, in order to
    ;; restore the live registers after the GC.  But if we put it on
    ;; the stack it it's original form, the GC will see it and try to
    ;; interpret it as an object reference.  So we disguise it as a
    ;; fixnum first.
    (emit-shl cg number-tag-bits %closure)
    (emit-push cg %closure)
    
    (emit-mov cg (fixnum-representation 0) %nargs)
    (emit cg "call ~A" gc-label)
    
    (emit-pop cg %closure)
    (emit-sar cg number-tag-bits %closure)
  
    ;; Restore live registers
    (for-live-registers (reverse general-registers) (function emit-pop))

    (emit cg "ret")))

;; the gc uses the raw-alloc operation

(define-operator (raw-alloc (size reg-imm)) ((temp-regs alloc))
  (emit-alloc cg (compiler-constant-value (attr-ref attrs 'tag-bits))
              (emit-scale-number cg value-scale size) alloc spare-regs)
  (emit-mov cg alloc result)
  result)

;;; Functions and closures

(define-operator (alloc-closure) ((temp-regs alloc))
  (emit-alloc cg closure-tag-bits
              (* value-size (1+ (length (attr-ref attrs 'closure))))
              alloc spare-regs)
  (emit-mov cg (attr-ref attrs 'label) (mem alloc))
  (emit-lea cg (mem1+ alloc closure-tag) result)
  result)

(define (closure-slot closure index)
  (tagged-mem closure-tag closure (1+ index)))

(define (emit-store-into-closure cg closure index val)
  (emit-mov cg val (closure-slot closure index)))

(define (codegen-function-intro label closure-size cg)
  (emit cg ".text")
  (emit-align  cg value-scale)
  (emit-literal cg (fixnum-representation closure-size))
  (emit cg ".globl ~A" label)
  (emit-smart-label cg label))

(define (emit-call-or-jump cg insn func)
  (let* ((label (func-lambda-label func))
         (comment (comment-form func)))
    (if label
        (emit cg "~A ~A # ~S" insn label comment)
        (emit cg "~A *~A # ~S" insn
              (value-sized (tagged-mem closure-tag %closure)) comment))))

(define-codegen (call attrs func . args)
  (with-saved-frame-base cg
    (codegen-call-args cg func args)
    (emit-mov cg (fixnum-representation (length args)) %nargs)
    (emit-call-or-jump cg "call" func))
  (emit-restore-%closure cg)
  %funcres)

(define (emit-restore-%closure cg)
  (when (codegen-have-closure cg)
    (emit-mov cg (closure-address-slot cg) %closure)))

;;; Quote

(define-operator (quote) ()
  (let* ((val (codegen-quoted (attr-ref attrs 'quoted) cg)))
    ;;; If the quoted form resulted in a label, that means it emitted
    ;;; code, and we need to switch back to the code section
    (unless (number? val) (emit cg ".text"))
    val))

;;; Variables

(define (varrec-operand varrec cg)
  (let* ((mode (varrec-attr varrec 'mode)))
    (cond ((eq? mode 'self) %closure)
          ((eq? mode 'top-level) (mem (varrec-attr varrec 'label)))
          (true
           (let* ((index (varrec-attr varrec 'index)))
             (cond ((eq? mode 'closure) (closure-slot %closure index))
                   ((eq? mode 'param) (param-slot cg index))
                   ((eq? mode 'local) (local-slot cg index))
                   (true (error "strange variable mode ~S" mode))))))))

(define-operator (define (val reg-mem-imm)) ()
  (varrec-attr-set! (attr-ref attrs 'varrec) 'index (codegen-frame-base cg))
  (emit-frame-push cg val)
  val)

(define-operator (set! (val reg-imm)) ()
  (emit-mov cg val (varrec-operand (attr-ref attrs 'varrec) cg))
  val)

(define-operator (ref) () (varrec-operand (attr-ref attrs 'varrec) cg))

;;; Function call-related internals

(define-tag-check function? closure-tag closure-tag-bits)

(define-cc-operator (check-arg-count) ()
  (emit-cmp cg (fixnum-representation (attr-ref attrs 'nparams)) %nargs)
  "e")

(define-operator (arg-count) () %nargs)

(define-operator (raw-args-base) ()
  (emit-lea cg (param-slot cg 0) result)
  result)

;;; Comparisons

(defmarco (define-cmp-operator name cc)
  (quasiquote (define-cc-operator ((unquote name) a (b reg-mem-imm)) () 
                (emit-cmp cg b a)
                (unquote cc))))
 
(define-cmp-operator eq? "e")
(define-cmp-operator = "e")
(define-cmp-operator /= "ne")
(define-cmp-operator > "g")
(define-cmp-operator >= "ge")
(define-cmp-operator < "l")
(define-cmp-operator <= "le")

;;; Conses

(define-tag-check pair? pair-tag pair-tag-bits)

(define-operator (cons (a reg-imm) (d reg-imm)) ((temp-regs alloc))
  (emit-alloc cg pair-tag-bits (* 2 value-size) alloc spare-regs)
  (emit-mov cg a (mem alloc))
  (emit-mov cg d (mem alloc 1))
  (emit-lea cg (mem1+ alloc pair-tag) result)
  result)

(define-operator (car a) () (tagged-mem pair-tag a))
(define-operator (cdr a) () (tagged-mem pair-tag a 1))

(define-operator (rplaca c (a reg-imm)) ()
  (emit-mov cg a (tagged-mem pair-tag c))
  c)

(define-operator (rplacd c (d reg-imm)) ()
  (emit-mov cg d (tagged-mem pair-tag c 1))
  c)

;;; Boxes

(define-operator (raw-make-box (val reg-imm)) ((temp-regs alloc))
  (emit-alloc cg box-tag-bits value-size alloc spare-regs)
  (emit-mov cg val (mem alloc))
  (emit-lea cg (mem1+ alloc box-tag) result)
  result)

(define-operator (raw-box-set! box (val reg-imm)) ()
  (emit-mov cg val (tagged-mem box-tag box))
  val)

(define-operator (raw-box-ref box) () (tagged-mem box-tag box))

;;; Symbols

(define-tag-check symbol? symbol-tag symbol-tag-bits)

(define-operator (symbol-name sym) () (tagged-mem symbol-tag sym))
(define-operator (symbol-id sym) () (tagged-mem symbol-tag sym 1))

(define-operator (raw-make-symbol (str reg-imm) (id reg-imm))
    ((temp-regs alloc))
  (emit-alloc cg symbol-tag-bits (* 2 value-size) alloc spare-regs)
  (emit-mov cg str (mem alloc))
  (emit-mov cg id (mem alloc 1))
  (emit-lea cg (mem1+ alloc symbol-tag) result)
  result)

;;;  Numbers

(define-tag-check number? number-tag number-tag-bits)

(define-operator (+ a (b reg-mem-imm)) ()
  (emit-add cg b a)
  a)

(define-operator (* a (b reg-mem-imm)) ()
  (emit-sar cg number-tag-bits a)
  (emit-imul cg b a)
  a)

(define-operator (negate a) ()
  (emit-neg cg a)
  a)

(define-operator (- a (b reg-mem-imm)) ()
  (emit-sub cg b a)
  a)

(define-operator (truncate (dividend fixed-reg %a) (divisor reg-mem))
                 ((temp-fixed-regs %d))
  (emit-mov cg dividend %d)
  (emit-extend-sign-bit cg %d)
  (emit-idiv cg divisor)
  (emit-shl cg number-tag-bits dividend)
  dividend)

(define-operator (rem (dividend fixed-reg %a) (divisor reg-mem))
                 ((temp-fixed-regs %d))
  (emit-mov cg dividend %d)
  (emit-extend-sign-bit cg %d)
  (emit-idiv cg divisor)
  %d)

(define-operator (logand a (b reg-mem-imm)) ()
  (emit-and cg b a)
  a)

(define-operator (logior a (b reg-mem-imm)) ()
  (emit-or cg b a)
  a)

(define-operator (logxor a (b reg-mem-imm)) ()
  (emit-xor cg b a)
  a)

;;; Strings and vectors

(define-tag-check string? string-tag string-tag-bits)
(define-tag-check vector? vector-tag vector-tag-bits)

(define-operator (make-vec len) ((temp-regs alloc saved-len))
  (let* ((tag (attr-ref attrs 'tag))
         (tag-bits (attr-ref attrs 'tag-bits))
         (scale (attr-ref attrs 'scale)))
    (emit-mov cg len saved-len)
    (emit-scale-number cg scale len)
    (emit-add cg value-size len)
    (emit-alloc cg tag-bits len alloc spare-regs scale)
    (emit-mov cg saved-len (mem alloc))
    (emit-lea cg (mem1+ alloc tag) result))
  result)

(define-operator (vec-length vec) () (tagged-mem (attr-ref attrs 'tag) vec))

(define (vec-slot attrs vec index)
  (mem-offset (mem-offset vec (- (attr-ref attrs 'header-size)
                                 (attr-ref attrs 'tag)))
              index))

(define-operator (vec-address vec (index reg-imm)) ()
  (let* ((scaled-index (emit-scale-number cg (attr-ref attrs 'scale) index)))
    (emit-lea cg (vec-slot attrs vec scaled-index) result))
  result)

(define-operator (raw-vec-ref vec (index reg-imm)) ()
  (let* ((scale (attr-ref attrs 'scale))
         (slot (vec-slot attrs vec (emit-scale-number cg scale index))))
    (if (and (= scale value-scale) (immediate? index))
        ;; the slot is a suitable memory operand to return directly
        slot
        (begin (emit-movzx cg slot result scale) result))))

(define-operator (raw-vec-set! vec (index reg-imm) (val reg-imm)) ()
  (let* ((scale (attr-ref attrs 'scale)))
    (emit-mov cg val (vec-slot attrs vec (emit-scale-number cg scale index))
              scale))
  val)

(define-simplify (copy-mem attrs src-addr dest-addr len)
  (overwrite-form form
    (let* ((sa-name (gensym))
           (da-name (gensym))
           (len-name (gensym)))
      (quasiquote
        (begin ()
          (define (unquote sa-name) (unquote src-addr))
          (define (unquote da-name) (unquote dest-addr))
          (define (unquote len-name) (unquote len))
          (if () (> () (ref (unquote sa-name)) (ref (unquote da-name)))
              (copy-mem-directed
                        ((forward . (unquote true)) (unquote-splicing attrs))
                        (ref (unquote sa-name)) (ref (unquote da-name))
                        (ref (unquote len-name)))
              (copy-mem-directed
                        ((forward . (unquote false)) (unquote-splicing attrs))
                        (ref (unquote sa-name)) (ref (unquote da-name))
                        (ref (unquote len-name))))))))
  (simplify form))

(define-operator (copy-mem-directed (src-addr fixed-reg %si)
                                    (dest-addr fixed-reg %di)
                                    (len fixed-reg %c))
                 ((temp-regs scaled-len))
  (let* ((tag (attr-ref attrs 'tag))
         (scale (attr-ref attrs 'scale)))
    (if (attr-ref attrs 'forward)
        (emit cg "cld")
        (begin
          ;; when coping backwards, we need to offset src-addr and dest-addr
          (emit cg "std")
          (emit-mov cg len scaled-len)
          (emit-scale-number cg scale scaled-len)
          (emit-lea cg (tagged-mem (ash 1 scale) src-addr scaled-len) src-addr)
          (emit-lea cg (tagged-mem (ash 1 scale) dest-addr scaled-len)
                    dest-addr)))
    (emit-sar cg number-tag-bits len)
    (emit-rep-movs cg scale))
  unspecified-representation)

;;; Raw memory access

(define-operator (raw-ref (addr reg-imm)) ()
  (emit-movzx cg (mem addr) result (attr-ref attrs 'scale))
  result)

(define-operator (raw-set! (addr reg-imm) (val reg-imm)) ()
  (emit-mov cg val (mem addr) (attr-ref attrs 'scale))
  val)

;;; Raw ops for the GC

(define-operator (raw-logand a (b reg-mem-imm)) ()
  (emit-and cg b a)
  a)

(define-operator (raw-- a (b reg-mem-imm)) ()
  (emit-sub cg b a)
  a)

(define-operator (raw-+ a (b reg-mem-imm)) ()
  (emit-add cg b a)
  a)

;;; Misc runtime support

(define-operator (fixnum->raw val) ()
  (emit-sar cg number-tag-bits val)
  val)

(define-operator (raw->fixnum val) ()
  (emit-shl cg number-tag-bits val)
  val)

(define-operator (raw-label) () (attr-ref attrs 'name))

(define (emit-set-ac-flag cg enable)
  (emit-pushf cg)
  (if enable
      (emit-or cg #x40000 (mem %sp) 2)
        ;; we can't use an immediate mask value, due to fixnum limitations
      (let* ((reg (first general-registers)))
        (emit-mov cg #x40000 reg 2)
        (emit-not cg reg 2)
        (emit-and cg reg (mem %sp) 2)))
  (emit-popf cg))

