;;; x86 bitness-independent code generation

;;; Assembly bits

(defconstant value-insn-size-suffix (string-ref insn-size-suffixes value-scale))

(define (emit-align cg scale)
  (emit cg ".align ~D" (ash 1 scale)))

;;; Registers and address modes
;;;
;;; - immediates are simply numbers or strings (representing assembler
;;; labels)
;;;
;;; - registers a vector of strings, giving the name of the register
;;; for the various scales
;;;
;;; - a memory reference a list of the form (offset regs...)

(define (immediate? x) (or (number? x) (string? x)))
(define (register? x) (vector? x))
(define (mem? x) (pair? x))

(define (mem-operand reg-or-imm)
  (cond ((immediate? reg-or-imm) (list reg-or-imm))
        ((register? reg-or-imm) (list 0 reg-or-imm))
        (true (error "can't make memory operand from ~A" reg-or-imm))))

(define (offset-operand reg offset)
  (unless (register? reg) (error "~A not a register" reg))
  (cond ((immediate? offset) (list offset reg))
        ((register? offset) (list 0 offset reg))
        (true (error "can't offset memory operand with ~A" offset))))

(define (offset-2-operand rega regb imm)
  (unless (register? rega) (error "~A not a register" rega))
  (unless (register? regb) (error "~A not a register" regb))
  (unless (immediate? imm) (error "~A not an immediate" imm))
  (list imm rega regb))

(define (indexed-operand reg imm)
  (unless (register? reg) (error "~A not a register" reg))
  (unless (number? imm) (error "~A not an immediate" imm))
  (list (* value-size imm) reg))

(define (tagged-operand tag reg imm)
  (unless (register? reg) (error "~A not a register" reg))
  (unless (number? imm) (error "~A not an immediate" imm))
  (list (- (* value-size imm) tag) reg))

(define (reoffset-operand base offset)
  (cond ((number? offset)
         (cons (+ offset (car base)) (cdr base)))
        ((register? offset)
         (list* (car base) offset (cdr base)))
        (true
         (error "can't offset memory operand with ~A" offset))))

(define (reoffset-2-operand base reg imm)
  (list* (+ imm (car base)) reg (cdr base)))

(define (reindex-operand base index)
  (reoffset-operand base (* value-size index)))


(defmacro (reg-asm-operand reg scale)
  (list 'register-variant reg scale))

(define (asm-operand x scale)
  (cond ((immediate? x) (format "$~A" x))
        ((vector? x) (reg-asm-operand x scale))
        ((pair? x)
         (cond ((null? (cdr x)) (absolute-asm-operand (car x)))
               ((null? (cddr x))
                (format "~A(~A)" (if (eq? 0 (car x)) "" (car x))
                         (reg-asm-operand (second x) value-scale)))
               (true
                (format "~A(~A,~A)" (if (eq? 0 (car x)) "" (car x))
                         (reg-asm-operand (third x) value-scale)
                         (reg-asm-operand (second x) value-scale)))))
        (true (error "strange operand ~S" x))))

(define (value-sized operand)
  (asm-operand operand value-scale))

(define (operand-using-reg? o r)
  (cond ((register? o) (eq? o r))
        ((mem? o) (member? r (cdr o)))
        (true false)))

;;; Operator argument constraints

(define (reg-mem-operand-constraint cg operand reg)
  (if (or (immediate? operand)
          (and (register? operand) (not (eq? operand reg))))
      (begin
        (emit-mov cg operand reg)
        reg)
      operand))

(define (reg-mem-imm-operand-constraint cg operand reg)
  (if (and (register? operand) (not (eq? operand reg)))
      (begin
        (emit-mov cg operand reg)
        reg)
      operand))

(define (reg-imm-operand-constraint cg operand reg)
  (if (or (mem? operand)
          (and (register? operand) (not (eq? operand reg))))
      (begin
        (emit-mov cg operand reg)
        reg)
      operand))

;;; Condition codes

(define (negate-cc cc)
  (if (eq? (string-ref cc 0) #\n)
      (substring cc 1 (1- (string-length cc)))
      (string-concat "n" cc)))

;;; Instructions

(defmacro (define-insn-2 name insn)
  (quasiquote
    (define ((unquote name) cg src dest . scale)
      (emit-insn-2 cg (unquote insn) src dest scale))))

(define (emit-insn-2 cg insn src dest scale)
  (set! scale (if (null? scale) value-scale (car scale)))
  (emit cg "~A~C ~A, ~A" insn (string-ref insn-size-suffixes scale)
        (asm-operand src scale) (asm-operand dest scale)))

(define-insn-2 emit-lea "lea")
(define-insn-2 emit-add "add")
(define-insn-2 emit-sub "sub")
(define-insn-2 emit-imul "imul")
(define-insn-2 emit-and "and")
(define-insn-2 emit-or "or")
(define-insn-2 emit-xor "xor")
(define-insn-2 emit-cmp "cmp")
(define-insn-2 emit-test "test")
(define-insn-2 emit-shl "shl")
(define-insn-2 emit-sar "sar")

(define (emit-clear cg reg . scale)
  (set! scale (if (null? scale) value-scale (car scale)))
  (emit-xor cg reg reg (min 2 scale)))

(define (emit-mov cg src dest . scale)
  (cond ((and (eq? src 0) (register? dest))
         (emit-clear cg dest))
        ((and (number? src) (register? dest) (> src 0) (< src 1000000))
         (emit-movzx cg src dest
                     (min 2 (if (null? scale) value-scale (car scale)))))
        (true
         (emit-insn-2 cg "mov" src dest scale))))

(define movzx-suffixes (vector (vector "b")
                               (vector "zbw" "w")
                               (vector "zbl" "zwl" "l")))

(define (emit-movzx-32 cg src dest src-scale dest-scale)
  (emit cg "mov~A ~A,~A"
        (vector-ref (vector-ref movzx-suffixes dest-scale) src-scale)
        (asm-operand src src-scale)
        (asm-operand dest dest-scale)))

(define (emit-push cg reg)
  (emit cg "push~C ~A" value-insn-size-suffix (value-sized reg)))

(define (emit-pop cg reg)
  (emit cg "pop~C ~A" value-insn-size-suffix (value-sized reg)))

(define (emit-set cg cc reg)
  (emit cg "set~A ~A" cc (asm-operand reg 0)))

(defmacro (define-insn-1 name insn)
  (quasiquote
    (define ((unquote name) cg oper . scale)
      (emit-insn-1 cg (unquote insn) oper
                   (if (null? scale) value-scale (car scale))))))

(define (emit-insn-1 cg insn oper scale)
  (emit cg "~A~C ~A" insn (string-ref insn-size-suffixes scale)
        (asm-operand oper scale)))

(define-insn-1 emit-neg "neg")
(define-insn-1 emit-not "not")
(define-insn-1 emit-idiv "idiv")

(define (emit-ret cg imm)
  (if (= 0 imm)
      (emit cg "ret")
      (emit cg "ret $~D" imm)))

(defmacro (define-insn-0 name insn)
  (quasiquote
    (define ((unquote name) cg . scale)
      (emit cg "~A~C" (unquote insn)
            (if (null? scale) value-insn-size-suffix
                (string-ref insn-size-suffixes (car scale)))))))

(define-insn-0 emit-rep-movs "rep ; movs")
(define-insn-0 emit-rep-stos "rep ; stos")
(define-insn-0 emit-pushf "pushf")
(define-insn-0 emit-popf "popf")

(define (emit-scale-number cg scale oper)
  (cond ((= scale number-tag-bits)
         oper)
        ((number? oper)
         (ash oper (- scale number-tag-bits)))
        ((< scale number-tag-bits)
         (let* ((shift (- number-tag-bits scale)))
           (if (register? oper)
               (begin (emit-sar cg shift oper) oper)
               (formout stdout "~A>>~A" oper shift))))
        (true
         (let* ((shift (- scale number-tag-bits)))
           (if (register? oper)
               (begin (emit-shl cg shift oper) oper)
               (formout stdout "~A<<~A" oper shift))))))

(define (emit-branch cg cc label)
  (emit-without-flushing "j~A ~A" cc label))

(define (emit-jump cg label)
  (emit-without-flushing "jmp ~A" label))

(define (emit-mov-maybe cg src dst)
  (unless (eq? src dst) (emit-mov cg src dst)))

(define (emit-branch-on-operand cg oper out-frame-base tlabel flabel)
  (emit-cmp cg false-representation oper)
  (emit-smart-branch cg "ne" out-frame-base tlabel flabel))

(define (emit-prepare-convert-cc-value cg reg)
  (emit-clear cg reg))

(define (emit-convert-cc-value cg cc reg)
  ;; this embeds special-tag and the representations of false and true
  (emit-set cg cc reg)
  (emit-shl cg special-tag-bits reg 0)
  (emit-or cg special-tag reg 0))

(defmacro (define-tag-check name tag tag-bits)
  (quasiquote
    (define-cc-operator ((unquote name) val) ()
      ;; just check the low-order byte
      (emit-and cg (low-bits-mask (unquote tag-bits)) val 0)
      (emit-cmp cg (unquote tag) val 0)
      "e")))

;;; Heap allocation

(define (register-bitset regs)
  (reduce (register-bit (car regs)) (cdr regs)
          (lambda (bits reg) (logior bits (register-bit reg)))))

(define (emit-alloc cg tag-bits size allocreg spare-regs . scale)
  (let* ((again-label (gen-label))
         (exhausted-label (gen-label)))
    (flush-labels-and-jumps cg)
    (emit-raw-label cg again-label)
    (emit-mov cg (mem-operand "heap_alloc") allocreg)
    (emit-sub cg size allocreg)
    (set! scale (if (null? scale) value-scale (car scale)))
    (unless (= tag-bits scale) (emit-and cg (- (ash 1 tag-bits)) allocreg))
    (emit-cmp cg (mem-operand "heap_threshold") allocreg)
    (emit-branch cg "be" exhausted-label)
    (emit-mov cg allocreg (mem-operand "heap_alloc"))

    (codegen-push-out-of-line cg
      (lambda ()
        (emit-raw-label cg exhausted-label)
        (emit-mov cg (register-bitset (cons allocreg spare-regs)) %closure)
        (emit cg "call heap_exhausted")
        (emit-restore-%closure cg)
        (emit-jump cg again-label)))))

(define gc-label (make-label-for 'gc direct-function-label-prefix))

(define (codegen-helpers cg)
  (labels ((for-live-registers (regs op)
             (dolist (reg regs)
               (let* ((l (gen-label)))
                 (emit-test cg (register-bit reg) %closure)
                 (emit-branch cg "nz" l)
                 (funcall op cg reg)
                 (emit-raw-label cg l)))))
    (emit cg ".text")
    (emit cg ".globl heap_exhausted")
    (emit cg "heap_exhausted:")

    ;; Push live registers onto the stack, guided by the bitset in
    ;; %closure.  This preserves their values, and also means that
    ;; they get treated as part of the root set by the GC.
    (for-live-registers general-registers (function emit-push))

    ;; We need to save the live reg bitset from %closure, in order to
    ;; restore the live registers after the GC.  But if we put it on
    ;; the stack it it's original form, the GC will see it and try to
    ;; interpret it as an object reference.  So we disguise it as a
    ;; fixnum first.
    (emit-shl cg number-tag-bits %closure)
    (emit-push cg %closure)
    (emit cg "call ~A" gc-label)
    (emit-pop cg %closure)
    (emit-sar cg number-tag-bits %closure)

    ;; Restore live registers
    (for-live-registers (reverse general-registers) (function emit-pop))

    (emit cg "ret")))

;; the gc uses the raw-alloc operation

(define-operator (raw-alloc (size reg-imm)) ((temp-regs alloc))
  (emit-alloc cg (compiler-constant-value (attr-ref attrs 'tag-bits))
              (emit-scale-number cg value-scale size) alloc spare-regs)
  (emit-mov cg alloc result)
  result)

;;; Functions and closures

(define-operator (alloc-closure)
                 ((temp-regs alloc)
                  (temp-fixed-regs %a %c %di)
                  )
  (let* ((slot-count (length (attr-ref attrs 'closure))))
    (emit-alloc cg closure-tag-bits (* value-size (1+ slot-count)) alloc
                (list* %a %c %di spare-regs))
    (emit-mov cg (first (attr-ref attrs 'labels)) (mem-operand alloc))
    (init-closure-slots cg unspecified-representation
                        (offset-operand alloc value-size)
                        slot-count value-scale)
    (emit-lea cg (offset-operand alloc closure-tag) result))
  result)

(define (init-closure-slots cg val base count scale)
  (cond ((= count 0))
        ((= count 1)
         (emit-mov cg val base))
        (true
         (emit-mov cg val %a)
         (if (<= count 4)
             (labels ((fill-from (index)
                        (when (< index count)
                          (emit-mov cg %a (reoffset-operand base
                                                            (ash index scale))
                                    scale)
                          (fill-from (1+ index)))))
               (fill-from 0))
             (begin
               (emit-lea cg base %di)
               (emit-mov cg count %c)
               (emit-rep-stos cg scale))))))

(define (closure-slot closure index)
  (tagged-operand closure-tag closure (1+ index)))

(define (emit-store-into-closure cg closure index val)
  (emit-mov cg val (closure-slot closure index)))

(define (emit-call-or-jump cg insn func nargs)
  (let* ((comment (comment-form func))
         (attrs (func-lambda-attrs func)))
    (if attrs
        (begin
          (check-call-nargs attrs nargs)
          (let* ((labels (attr-ref attrs 'labels))
                 (label (if (null? (cdr labels))
                            (begin
                              (emit-mov cg (fixnum-representation nargs) %nargs)
                              (first labels))
                            (second labels))))
            (emit cg "~A ~A # ~S" insn label comment)))
        (begin
          (emit-mov cg (fixnum-representation nargs) %nargs)
          (emit cg "~A *~A # ~S" insn
                (value-sized (tagged-operand closure-tag %closure 0))
                comment)))))

(define-codegen (call attrs func . args)
  (with-saved-frame-base cg
    (codegen-call-args cg func args)
    (emit-call-or-jump cg "call" func (length args)))
  (emit-restore-%closure cg)
  %funcres)

(define (emit-restore-%closure cg)
  (when (codegen-have-closure cg)
    (emit-mov cg (closure-address-slot cg) %closure)))

;;; Variables

(define (varrec-operand varrec cg)
  (let* ((mode (varrec-attr varrec 'mode)))
    (cond ((eq? mode 'self) %closure)
          ((eq? mode 'top-level) (mem-operand (varrec-attr varrec 'label)))
          (true
           (let* ((index (varrec-attr varrec 'index)))
             (cond ((eq? mode 'closure) (closure-slot %closure index))
                   ((eq? mode 'param) (param-slot cg index))
                   ((eq? mode 'local) (local-slot cg index))
                   (true (error "strange variable mode ~S" mode))))))))

(define-operator (define (val reg-mem-imm)) ()
  (emit-frame-push cg val)
  (varrec-attr-set! (attr-ref attrs 'varrec) 'index (codegen-frame-base cg))
  val)

(define-operator (set! (val reg-imm)) ()
  (emit-mov cg val (varrec-operand (attr-ref attrs 'varrec) cg))
  val)

(define-operator (ref) () (varrec-operand (attr-ref attrs 'varrec) cg))

;;; Function call-related internals

(define-tag-check function? closure-tag closure-tag-bits)

(define (emit-check-nargs cg nparams bad-nargs-label)
  (emit-cmp cg (fixnum-representation nparams) %nargs)
  (emit-branch cg "ne" bad-nargs-label))

(define-operator (arg-count) () %nargs)

(define-operator (raw-args-base) ()
  (emit-lea cg (param-slot cg 0) result)
  result)

;;; Comparisons

(defmacro (define-cmp-operator name cc)
  (quasiquote (define-cc-operator ((unquote name) a (b reg-mem-imm)) ()
                (emit-cmp cg b a)
                (unquote cc))))

(define-cmp-operator eq? "e")
(define-cmp-operator = "e")
(define-cmp-operator /= "ne")
(define-cmp-operator > "g")
(define-cmp-operator >= "ge")
(define-cmp-operator < "l")
(define-cmp-operator <= "le")

;;; Conses

(define-tag-check pair? pair-tag pair-tag-bits)

(define-operator (cons (a reg-imm) (d reg-imm)) ((temp-regs alloc))
  (emit-alloc cg pair-tag-bits (* 2 value-size) alloc spare-regs)
  (emit-mov cg a (mem-operand alloc))
  (emit-mov cg d (indexed-operand alloc 1))
  (emit-lea cg (offset-operand alloc pair-tag) result)
  result)

(define-operator (car a) () (tagged-operand pair-tag a 0))
(define-operator (cdr a) () (tagged-operand pair-tag a 1))

(define-operator (rplaca c (a reg-imm)) ()
  (emit-mov cg a (tagged-operand pair-tag c 0))
  c)

(define-operator (rplacd c (d reg-imm)) ()
  (emit-mov cg d (tagged-operand pair-tag c 1))
  c)

;;; Boxes

(define-operator (raw-make-box (val reg-imm)) ((temp-regs alloc))
  (emit-alloc cg box-tag-bits value-size alloc spare-regs)
  (emit-mov cg val (mem-operand alloc))
  (emit-lea cg (offset-operand alloc box-tag) result)
  result)

(define-operator (raw-box-set! box (val reg-imm)) ()
  (emit-mov cg val (tagged-operand box-tag box 0))
  val)

(define-operator (raw-box-ref box) ()
  (tagged-operand box-tag box 0))

;;; Symbols

(define-tag-check symbol? symbol-tag symbol-tag-bits)

(define-operator (symbol-name sym) ()
  (tagged-operand symbol-tag sym 0))

(define-operator (symbol-id sym) ()
  (tagged-operand symbol-tag sym 1))

(define-operator (raw-make-symbol (str reg-imm) (id reg-imm))
    ((temp-regs alloc))
  (emit-alloc cg symbol-tag-bits (* 2 value-size) alloc spare-regs)
  (emit-mov cg str (mem-operand alloc))
  (emit-mov cg id (indexed-operand alloc 1))
  (emit-lea cg (offset-operand alloc symbol-tag) result)
  result)

;;;  Numbers

(define-tag-check number? number-tag number-tag-bits)

(define-operator (+ a (b reg-mem-imm)) ()
  (emit-add cg b a)
  a)

(define-operator (* a (b reg-mem-imm)) ()
  (emit-sar cg number-tag-bits a)
  (emit-imul cg b a)
  a)

(define-operator (negate a) ()
  (emit-neg cg a)
  a)

(define-operator (- a (b reg-mem-imm)) ()
  (emit-sub cg b a)
  a)

(define-operator (truncate (dividend fixed-reg %a) (divisor reg-mem))
                 ((temp-fixed-regs %d))
  (emit-mov cg dividend %d)
  (emit-extend-sign-bit cg %d)
  (emit-idiv cg divisor)
  (emit-shl cg number-tag-bits dividend)
  dividend)

(define-operator (rem (dividend fixed-reg %a) (divisor reg-mem))
                 ((temp-fixed-regs %d))
  (emit-mov cg dividend %d)
  (emit-extend-sign-bit cg %d)
  (emit-idiv cg divisor)
  %d)

(define-operator (logand a (b reg-mem-imm)) ()
  (emit-and cg b a)
  a)

(define-operator (logior a (b reg-mem-imm)) ()
  (emit-or cg b a)
  a)

(define-operator (logxor a (b reg-mem-imm)) ()
  (emit-xor cg b a)
  a)

;;; Strings and vectors

(define-tag-check string? string-tag string-tag-bits)
(define-tag-check vector? vector-tag vector-tag-bits)

(define-operator (make-vec len (init fixed-reg %a))
                 ((temp-regs alloc) (temp-fixed-regs %c %di))
  (let* ((tag (attr-ref attrs 'tag))
         (tag-bits (attr-ref attrs 'tag-bits))
         (scale (attr-ref attrs 'scale)))
    (emit-mov cg len %c)
    (emit-scale-number cg scale len)
    (emit-add cg value-size len)
    (emit-alloc cg tag-bits len alloc (list* %di spare-regs) scale)
    (emit-mov cg alloc %di)
    (emit-mov cg %c (mem-operand alloc))
    (emit-add cg value-size %di)
    (emit-scale-number cg 0 %c)
    (emit-rep-stos cg scale)
    (emit-lea cg (offset-operand alloc tag) result))
  result)

(define-operator (vec-length vec) ()
  (tagged-operand (attr-ref attrs 'tag) vec 0))

(define (vec-slot cg attrs vec index)
  (let* ((offset (- (attr-ref attrs 'header-size) (attr-ref attrs 'tag)))
         (scaled-index  (emit-scale-number cg (attr-ref attrs 'scale) index)))
    (if (number? scaled-index)
        (offset-operand vec (+ offset scaled-index))
        (offset-2-operand vec scaled-index offset))))

(define-operator (vec-address vec (index reg-imm)) ()
  (emit-lea cg (vec-slot cg attrs vec index) result)
  result)

(define-operator (raw-vec-ref vec (index reg-imm)) ()
  (let* ((slot (vec-slot cg attrs vec index))
         (scale (attr-ref attrs 'scale)))
    (if (and (= scale value-scale) (immediate? index))
        ;; The slot is a suitable memory operand to return directly.
        ;; The 'immediate? index' condition is important, due to its
        ;; interaction with the code generation strategy: It ensures
        ;; that we only return memory operands that involve the'vec'
        ;; register that was reserved for our result anyway.  If that
        ;; condition is omitted, we might produce an operand that
        ;; involves the 'index' register, and that might get trampled
        ;; on before the memory operand is used.
        slot
        (begin (emit-movzx cg slot result scale)
               result))))

(define-operator (raw-vec-set! vec (index reg-imm) (val reg-imm)) ()
  (emit-mov cg val (vec-slot cg attrs vec index) (attr-ref attrs 'scale))
  val)

(define-simplify (copy-mem attrs src-addr dest-addr len)
  (overwrite-form form
    (let* ((sa-name (gensym))
           (da-name (gensym))
           (len-name (gensym)))
      (quasiquote
        (begin ()
          (define (unquote sa-name) (unquote src-addr))
          (define (unquote da-name) (unquote dest-addr))
          (define (unquote len-name) (unquote len))
          (if () (> () (ref (unquote sa-name)) (ref (unquote da-name)))
              (copy-mem-directed
                        ((forward . (unquote true)) (unquote-splicing attrs))
                        (ref (unquote sa-name)) (ref (unquote da-name))
                        (ref (unquote len-name)))
              (copy-mem-directed
                        ((forward . (unquote false)) (unquote-splicing attrs))
                        (ref (unquote sa-name)) (ref (unquote da-name))
                        (ref (unquote len-name))))))))
  (simplify form))

(define-operator (copy-mem-directed (src-addr fixed-reg %si)
                                    (dest-addr fixed-reg %di)
                                    (len fixed-reg %c))
                 ((temp-regs scaled-len))
  (let* ((tag (attr-ref attrs 'tag))
         (scale (attr-ref attrs 'scale))
         (forward (attr-ref attrs 'forward)))
    (unless forward
      ;; when copying backwards, we need to offset src-addr and dest-addr
      (emit cg "std")
      (emit-mov cg len scaled-len)
      (emit-scale-number cg scale scaled-len)
      (emit-lea cg (offset-2-operand src-addr scaled-len (ash -1 scale))
                src-addr)
      (emit-lea cg (offset-2-operand dest-addr scaled-len (ash -1 scale))
                dest-addr))
    (emit-sar cg number-tag-bits len)
    (emit-rep-movs cg scale)
    (unless forward (emit cg "cld")))
  unspecified-representation)

;;; Raw memory access

(define-operator (raw-ref (addr reg-imm)) ()
  (emit-movzx cg (mem-operand addr) result (attr-ref attrs 'scale))
  result)

(define-operator (raw-set! (addr reg-imm) (val reg-imm)) ()
  (emit-mov cg val (mem-operand addr) (attr-ref attrs 'scale))
  val)

;;; Raw ops for the GC

(define-operator (raw-logand a (b reg-mem-imm)) ()
  (emit-and cg b a)
  a)

(define-operator (raw-- a (b reg-mem-imm)) ()
  (emit-sub cg b a)
  a)

(define-operator (raw-+ a (b reg-mem-imm)) ()
  (emit-add cg b a)
  a)

;;; Misc runtime support

(define-operator (fixnum->raw val) ()
  (emit-sar cg number-tag-bits val)
  val)

(define-operator (raw->fixnum val) ()
  (emit-shl cg number-tag-bits val)
  val)

(define-operator (raw-label) () (attr-ref attrs 'name))

(define-operator (raw-global-set! (val reg-imm)) ()
  (emit-mov cg val (mem-operand (subject-language-symbol-name
                                 (attr-ref attrs 'name))))
  val)

(define-operator (raw-global-ref) ()
  (mem-operand (subject-language-symbol-name (attr-ref attrs 'name))))

(define (emit-set-ac-flag cg enable)
  (emit-pushf cg)
  (if enable
      (emit-or cg #x40000 (mem-operand %sp) 2)
        ;; we can't use an immediate mask value, due to fixnum limitations
      (let* ((reg (first general-registers)))
        (emit-mov cg #x40000 reg 2)
        (emit-not cg reg 2)
        (emit-and cg reg (mem-operand %sp) 2)))
  (emit-popf cg))

