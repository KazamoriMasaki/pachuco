;;; Stack handling, without a frame pointer

;;; %bp is available as a general register
(add-general-registers (list %bp))

;;; Stack layout:
;;;
;;; param N
;;; ...
;;; param 1
;;; param 0  <--- %sp + (frame-base * value-size)
;;; Return address
;;; %closure
;;; Local var 0
;;; ...
;;; Local var N
;;; in-progress param N
;;; in-progress param N-1
;;; ...
;;;
;;; Functions are called with the closure in %closure, arg-count in
;;; %nargs.  They return with the result in %funcres.

(define (return-address-slot cg)
  (indexed-operand %sp (1- (codegen-frame-base cg))))

(define (closure-address-slot)
  (frame-slot 2))

(define (normalize-frame-slot cg index)
  (indexed-operand %sp (- (codegen-frame-base cg) index)))

;;; Functions, calls, returns, etc.

(define (emit-function-prologue cg)
  (codegen-set-frame-base! cg 1))

(define-operator (return (retval fixed-reg %funcres)) (tail-form)
  (emit-reset-frame-base cg 1)
  (emit-ret cg (* value-size (attr-ref attrs 'nparams)))
  (codegen-function-tail cg out-frame-base))

(define-operator (varargs-return arg-count (retval fixed-reg %funcres))
                 (tail-form (temp-regs retaddr))
  ;; We need to clean up the stack before returning, but the return
  ;; address is on the top.  And we can't simply pop the return
  ;; address and later do an indirect branch to it, because that is
  ;; bad for branch prediction.  So we copy the return address into
  ;; to the top of the argument area, then return
  (emit-scale-number cg value-scale arg-count)
  (emit-mov cg (return-address-slot cg) retaddr)
  (emit-lea cg (reoffset-operand (return-address-slot cg) arg-count) %sp)
  (emit-mov cg retaddr (mem-operand %sp))
  (emit cg "ret")
  (codegen-function-tail cg out-frame-base))

(define-trashy-codegen (tail-call attrs . args) (tail-form)
  (let* ((operands (trashy-codegen-general cg form
                                     (function not-closure-operand-constraint)))
         (assignments-base (codegen-tail-call-shuffle cg attrs operands
                                                      (list (frame-slot 1)))))
    (emit-reset-frame-base cg assignments-base)
    (emit-call-or-jump cg attrs "jmp")
    (codegen-function-tail cg out-frame-base)))

(define-codegen-discarding (varargs-tail-call attrs arg-count . args)
  (codegen-call-args cg attrs args)
  (let* ((out-arg-count (attr-ref attrs 'nargs))
         (retaddr (return-address-slot cg))
         (out-retaddr-reg (first general-registers))
         (tmpreg (second general-registers))
         (saved-retaddr-reg (third general-registers)))
    ;; Compute the intended location of the return address on the
    ;; stack.  Here we assume that the arg-count is just a ref, and so
    ;; won't access %closure
    (trashy-codegen-into-reg arg-count cg false out-retaddr-reg)
    (emit-scale-number cg value-scale out-retaddr-reg)
    (emit-lea cg (reoffset-2-operand retaddr out-retaddr-reg
                                     (* value-size (- out-arg-count)))
              out-retaddr-reg)
    ;; Stash the return address
    (emit-mov cg retaddr saved-retaddr-reg)
    ;; Copy the arguments to their intended locations
    (copy-tail-call-args cg out-arg-count (mem-operand out-retaddr-reg) tmpreg)
    ;; Fix up the return address on the stack and jump
    (emit-mov cg out-retaddr-reg %sp)
    (emit-mov cg saved-retaddr-reg (mem-operand %sp))
    (emit-call-or-jump cg attrs "jmp")
    (codegen-function-tail cg out-frame-base)))

;;; Apply support

(define-operator (raw-jump-with-arg-space before-arg-count after-arg-count
                                          bodyfunc)
                 (tail-form (temp-regs retaddr))
  ;; calculate how far up to move %sp
  (emit-sub cg after-arg-count before-arg-count)
  (emit-mov cg bodyfunc %closure)
  (emit-scale-number cg value-scale before-arg-count)
  (emit-mov cg (return-address-slot cg) retaddr)
  (emit-lea cg (reoffset-operand (return-address-slot cg) before-arg-count) %sp)
  (emit-mov cg retaddr (mem-operand %sp))
  (emit-call-or-jump cg attrs "jmp")
  (codegen-function-tail cg out-frame-base))

(define-operator (raw-apply-jump func (arg-count fixed-reg %nargs)) (tail-form)
  (emit-reset-frame-base cg 1)
  (emit-mov cg func %closure)
  (emit-indirect-call-or-jump cg "jmp")
  (codegen-function-tail cg out-frame-base))

;;; C-callable program wrapper

(define (codegen-program program)
  (let* ((cg (make-codegen)))
    (codegen-program-start cg program)

    (emit cg ".text")
    (emit-function-label cg "lisp")
    (dolist (reg c-callee-saved-regs) (emit-push cg reg))
    (emit-set-ac-flag cg true)

    (codegen-set-frame-base! cg 0)
    (codegen-body cg program 0)

    (emit-set-ac-flag cg false)
    (dolist (reg (reverse c-callee-saved-regs)) (emit-pop cg reg))
    (emit cg "ret")

    (codegen-do-out-of-line cg)
    (emit cg ".size lisp, .-lisp")

    (codegen-program-end cg)))
