;;; Stack handling, without a frame pointer

;;; %bp is available as a general register
(add-general-registers (list %bp))

;;; Stack layout:
;;;
;;; param N
;;; ...
;;; param 1
;;; param 0
;;; Return address
;;; %closure  <--- (mem %sp frame-base)
;;; Local var 0
;;; ...
;;; Local var N
;;; in-progress param N
;;; in-progress param N-1
;;; ...
;;;
;;; Functions are called with the closure in %closure, arg-count in
;;; %nargs.  They return with the result in %funcres.

(define (return-address-slot cg)
  (mem %sp (+ (codegen-frame-base cg) (if (codegen-have-closure cg) 1 0))))

(define (closure-address-slot cg)
  (mem %sp (codegen-frame-base cg)))

;;; Functions, calls, returns, etc.

(define (codegen-function label closure-size body cg) 
  (codegen-function-intro label closure-size cg)
  (when (codegen-have-closure cg) (emit-push cg %closure))
  (trashy-codegen-discarding body cg (if (codegen-have-closure cg) -1 0))
  (codegen-do-out-of-line cg))

(define-operator (return (retval fixed-reg %funcres)) (tail-form)
  (emit-reset-frame-base cg out-frame-base)
  (emit-ret cg (* value-size (attr-ref attrs 'nparams))))

(define-operator (varargs-return arg-count (retval fixed-reg %funcres))
                 (tail-form (temp-regs retaddr))
  ;; We need to clean up the stack before returning, but the return
  ;; address is on the top.  And we can't simply pop the return
  ;; address and later do an indirect branch to it, because that is
  ;; bad for branch prediction.  So we copy the return address into
  ;; to the top of the argument area, then return
  (emit-scale-number cg value-scale arg-count)
  (emit-mov cg (return-address-slot cg) retaddr)
  (emit-lea cg (mem (return-address-slot cg) arg-count) %sp)
  (emit-mov cg retaddr (mem %sp))
  (emit cg "ret"))

(define (codegen-tail-call func retaddr out-arg-count out-retaddr
                           out-frame-base regs cg)
  (let* ((tmpreg (first regs))
         (retaddr-reg (second regs)))
    (emit-mov cg retaddr retaddr-reg)
    (copy-tail-call-args cg out-arg-count out-retaddr tmpreg)
    (emit-lea cg (mem out-retaddr) %sp)
    (emit-mov cg retaddr-reg (mem %sp))
    ;; setting up %nargs must be the last thing we do, since %nargs is
    ;; in general-regs and so might be the same as one of our temp
    ;; regs
    (emit-mov cg (fixnum-representation out-arg-count) %nargs)
    (emit-call-or-jump cg "jmp" func)
    (codegen-set-frame-base! cg out-frame-base)))

(define-codegen-discarding (tail-call attrs func . args)
  (codegen-call-args cg func args)
  (let* ((in-arg-count (attr-ref attrs 'nparams))
         (out-arg-count (length args))
         (retaddr (return-address-slot cg))
         (out-retaddr (mem retaddr (- in-arg-count out-arg-count))))
    (if (= in-arg-count out-arg-count)
        (begin 
          (copy-tail-call-args cg out-arg-count out-retaddr 
                               (first general-registers))
          (emit-reset-frame-base cg out-frame-base)
          ;; setting up %nargs must be the last thing we do, since
          ;; %nargs is in general-regs and so might be the same as one
          ;; of our temp regs
          (emit-mov cg (fixnum-representation out-arg-count) %nargs)
          (emit-call-or-jump cg "jmp" func))
        (codegen-tail-call func retaddr out-arg-count out-retaddr
                           out-frame-base general-registers cg))))

(define-codegen-discarding (varargs-tail-call attrs arg-count func . args)
  (codegen-call-args cg func args)
  (let* ((in-arg-count-reg (first general-registers))
         (out-arg-count (length args))
         (retaddr (return-address-slot cg)))
    ;; here we assume that the arg-count is just a ref, and so won't
    ;; access %closure
    (trashy-codegen-into-reg arg-count cg false in-arg-count-reg)
    (emit-scale-number cg value-scale in-arg-count-reg)
    (emit-lea cg (mem retaddr in-arg-count-reg (- out-arg-count)) 
              in-arg-count-reg)
    (codegen-tail-call func retaddr out-arg-count in-arg-count-reg 
                       out-frame-base (cdr general-registers) cg)))

;;; Apply support

(define-operator (raw-jump-with-arg-space before-arg-count after-arg-count
                                          bodyfunc)
                 (tail-form (temp-regs retaddr))
  ;; calculate how far up to move %sp
  (emit-sub cg after-arg-count before-arg-count)
  (emit-mov cg bodyfunc %closure)
  (emit-scale-number cg value-scale before-arg-count)
  (emit-mov cg (return-address-slot cg) retaddr)
  (emit-lea cg (mem (return-address-slot cg) before-arg-count) %sp)
  (emit-mov cg retaddr (mem %sp))
  (emit-clear cg %nargs)
  (emit cg "jmp *~A" (value-sized (tagged-mem closure-tag bodyfunc))))

(define-operator (raw-apply-jump func (arg-count fixed-reg %nargs)) (tail-form)
  (emit-reset-frame-base cg out-frame-base)
  (emit-mov cg func %closure)
  (emit cg "jmp *~A" (value-sized (tagged-mem closure-tag %closure))))

;;; C-callable program wrapper

(define (codegen-program program)
  (let* ((cg (make-codegen)))
    (codegen-program-sections program cg)
    
    (emit cg ".text")
    (emit cg ".globl lisp")
    (emit cg "lisp:")
    (dolist (reg c-callee-saved-regs) (emit-push cg reg))
    (emit-set-ac-flag cg true)

    (codegen-set-frame-base! cg 0)
    (codegen-set-have-closure! cg false)
    (trashy-codegen-discarding program cg false)

    (emit-set-ac-flag cg false)
    (emit cg "cld")
    (dolist (reg (reverse c-callee-saved-regs)) (emit-pop cg reg))
    (emit cg "ret")
    
    (codegen-do-out-of-line cg)
    (codegen-heap-exhausted cg)))
