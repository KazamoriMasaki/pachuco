;; codegen emits the code for the form.
(define-walker codegen (cg out-frame-base regs reg))
(define (codegen-recurse form cg out-frame-base regs reg)
  (error "codegen on unknown form ~S" (car form)))

;; reg-use returns the number of registers needed for the code
;; generated by codegen.
;;
;; The result should not be greater than general-register-count.
(define-walker reg-use ())
(define (reg-use-recurse form)
  (error "reg-use on unknown form ~S" (car form)))

;; codegen-discarding emits code to evaluate the form, in a context
;; where the resulting value is not used.
(define-walker codegen-discarding (cg out-frame-base regs))

;; reg-use-discarding returns the number of registers needed for the
;; code generated by codegen-discarding.
(define-walker reg-use-discarding ())

;; codegen-conditional emits code to evaluate the form, in a
;; conditional context.
(define-walker codegen-conditional (cg out-frame-base regs tlabel flabel))

;; reg-use-conditional returns the number of registers needed for the
;; code generated by codegen-conditional.
(define-walker reg-use-conditional ())

;;; codegen and reg-use fallbacks

(define (codegen-into-reg form cg out-frame-base regs reg)
  (emit-mov-maybe cg (codegen form cg out-frame-base regs reg) reg))

(define (reg-use-discarding-recurse form)
  (reg-use form))

(define (codegen-discarding-recurse form cg out-frame-base regs)
  (codegen form cg out-frame-base regs (if (null? regs) false (first regs))))

(define (reg-use-conditional-recurse form)
  (reg-use form))

(define (codegen-conditional-recurse form cg out-frame-base regs tlabel flabel)
  (emit-branch-on-operand cg (codegen form cg out-frame-base regs
                                      (if (null? regs) false (first regs)))
                          out-frame-base tlabel flabel))

;;; codegen functions called from outside this file

(define (trashy-codegen form cg out-frame-base)
  (reg-use form)
  (codegen form cg out-frame-base general-registers (first general-registers)))

(define (trashy-codegen-discarding form cg out-frame-base)
  (reg-use-discarding form)
  (codegen-discarding form cg out-frame-base general-registers))

(define (trashy-codegen-into-reg form cg out-frame-base reg)
  (reg-use form)
  (emit-mov-maybe cg (codegen form cg out-frame-base general-registers reg)
                  reg))

(defmacro (define-trashy-codegen template . body)
  (quasiquote (definitions
    (define-reg-use (unquote template)
      (dolist (arg (cddr form)) (reg-use arg))
      general-register-count)

    (define-codegen (unquote template)
      (unquote-splicing body)))))

;;; Begin

(define (reg-use-begin forms max-ru reg-use-last)
  ;; work out the reg-use of forms, using reg-use-last to evaluate the
  ;; reg-use of the last form
  (if (null? (cdr forms))
      (max max-ru (funcall reg-use-last (car forms)))
      (reg-use-begin (cdr forms) (max max-ru (reg-use-discarding (car forms)))
                     reg-use-last)))

(define (codegen-begin-non-final cg forms regs)
  (if (null? (cdr forms))
      (begin
        (emit-comment-form cg (car forms))
        (car forms))
      (begin
        (emit-comment-form cg (car forms))
        (codegen-discarding (car forms) cg false regs)
        (codegen-begin-non-final cg (cdr forms) regs))))

(define-reg-use (begin varrecs . body)
  (reg-use-begin body 1 (function reg-use)))

;; We always attempt to reset the frame-base at the end of a begin.
;; Sometimes this won't do anything, because the last form in the
;; begin will have taken care of it (e.g. a nested begin).  But
;; checking there means that most forms can ignore out-frame-base

(define-codegen (begin varrecs . body)
  (unless out-frame-base (set! out-frame-base (codegen-frame-base cg)))
  ;; we make sure that the result goes into a register, because any
  ;; operand that depends on the frame-base might no longer be valid
  ;; if we alter the frame-base
  (codegen-into-reg (codegen-begin-non-final cg body regs) cg out-frame-base
                    regs (first regs))
  (emit-reset-frame-base cg out-frame-base)
  (first regs))

(define-reg-use-discarding (begin varrecs . body)
  (reg-use-begin body 0 (function reg-use-discarding)))

(define-codegen-discarding (begin varrecs . body)
  (unless out-frame-base (set! out-frame-base (codegen-frame-base cg)))
  (codegen-discarding (codegen-begin-non-final cg body regs)
                      cg out-frame-base regs)
  (emit-reset-frame-base cg out-frame-base))

(define-reg-use-conditional (begin varrecs . body)
  (reg-use-begin body 0 (function reg-use-conditional)))

(define-codegen-conditional (begin varrecs . body)
  (unless out-frame-base (set! out-frame-base (codegen-frame-base cg)))
  (codegen-conditional (codegen-begin-non-final cg body regs)
                       cg out-frame-base regs tlabel flabel)
  ;; codegen-conditional should always handle the reset-frame-base
  )

;;; If

(define (codegen-if test then else cg out-frame-base regs codegen-clause)
  (let* ((l1 (gen-label))
         (l2 (gen-label))
         (l3 (gen-label)))
    (codegen-conditional test cg false regs l1 l2)
    (emit-smart-label cg l1)
    (with-saved-frame-base cg
      (emit-comment-form cg then)
      (funcall codegen-clause then)
      (emit-reset-frame-base cg out-frame-base))
    (emit-smart-jump cg l3)
    (emit-smart-label cg l2)
    (emit-comment-form cg else)
    (funcall codegen-clause else)
    (emit-reset-frame-base cg out-frame-base)
    (emit-smart-label cg l3)))

(define-reg-use (if attrs test then else)
  (max 1 (reg-use-conditional test) (reg-use then) (reg-use else)))

(define-codegen (if attrs test then else)
  (codegen-if test then else cg out-frame-base regs
            (lambda (form) (codegen-into-reg form cg out-frame-base regs reg)))
  reg)

(define-reg-use-discarding (if attrs test then else)
  (max (reg-use-conditional test) (reg-use-discarding then)
       (reg-use-discarding else)))

(define-codegen-discarding (if attrs test then else)
  (codegen-if test then else cg out-frame-base regs
              (lambda (form) (codegen-discarding form cg out-frame-base regs))))

(define-reg-use-conditional (if attrs test then else)
  (max (reg-use-conditional test) (reg-use-conditional then)
       (reg-use-conditional else)))

(define-codegen-conditional (if attrs test then else)
  (codegen-if test then else cg out-frame-base regs
    (lambda (form)
      (codegen-conditional form cg out-frame-base regs tlabel flabel))))

;;; Operator support

(define (operator-args-reg-use form)
  ;; Find the number of registers required for evaluation of the
  ;; arguments of an operator
  (let* ((count 0)
         ;; calcuate the reg-use of each argument, and sort them into
         ;; descending order - this is more-or-less the order we will
         ;; evaluate them in operator-args-codegen
         (args-ru (sort (mapfor (arg (cddr form))
                          (let* ((index count))
                            (set! count (1+ count))
                            (cons index (reg-use arg))))
                        (lambda (a b) (> (cdr a) (cdr b)))))
         (trashy-args ())
         (non-trashy-args ())
         (intermediates 0)
         (max-ru 0))
    ;; We now proceed through the arguments, clasifying them into
    ;; non-trashy-args (whose results can be kept in registers) and
    ;; trashy-args (whose results must be put on the stack).
    ;; intermediates holds the number of registers needed to hold
    ;; intermediate results during the evaluation of each argument.
    (dolist (arg-ru args-ru)
      (let* ((ru (+ intermediates (cdr arg-ru))))
        (when (> ru max-ru) (set! max-ru ru))
        (if (> ru general-register-count)
          (begin
            ;; we cannot satisfy the register requirements of the
            ;; argument while holding the intermediates, so classify
            ;; it as trashy
            (rplacd arg-ru trashy-args)
            (set! trashy-args arg-ru))
          (begin
            (rplacd arg-ru non-trashy-args)
            (set! non-trashy-args arg-ru)
            (set! intermediates (1+ intermediates))))))

    ;; Stash the trashy-args and non-trashy-args lists for
    ;; operator-args-codegen.  Note that they are left in descending
    ;; order of reg-use, i.e. the reverse of the order of evaluation.
    (rplaca (cdr form) (list* (cons 'trashy-args trashy-args)
                              (cons 'non-trashy-args non-trashy-args)
                              (cadr form)))

    ;; This result doesn't include the point where all the operands
    ;; are potentially reloaded into registers, ready for the operator
    ;; body.  The caller should take care of that.
    (min max-ru general-register-count)))

(define (operator-args-codegen form cg regs operand-constraints)
  ;; Generate the code to evaluate the arguments of an operator
  (let* ((trashy-args (form-attr form 'trashy-args))
         (non-trashy-args (form-attr form 'non-trashy-args))
         (args (cddr form)))
    (when (> (length args) (length regs))
      (error "more operator arguments than available registers in ~S"
             (comment-form form)))

    ;; First, evaluate the trashy args, saving their results on the
    ;; stack.
    (dolist (arg trashy-args)
      (emit-frame-push cg (codegen (elt args arg) cg false regs (first regs))))

    ;; Work out the register list for evaluating the non-trashy args,
    ;; so that the result of each evaluation ends up in the correct
    ;; register.  Note that operator-args-reg-use left the
    ;; non-trashy-arg list in reverse order of evaluation,
    (let* ((non-trashy-regs (copy-list regs))
           (result-regs ())
           (output-operands (copy-list regs))
           (unused-operand-regs ()))
      ;; Move the regs that will take the results of trashy-args to
      ;; the start of non-trashy-regs
      (dolist (arg non-trashy-args)
        (let* ((c (nthcdr arg non-trashy-regs)))
          (push (car c) result-regs)
          (rplaca c false)))

      (set! non-trashy-regs (nconc result-regs (delete false non-trashy-regs)))

      ;; Now generate code for non-trashy args.  Non-trashy args don't
      ;; always produce register operands.  For example, they can
      ;; produce memory or immediate operands.  So we replace the
      ;; corresponding entries in output-operands with the actual
      ;; operands.
      (dolist (arg (reverse non-trashy-args))
        (let* ((c (nthcdr arg output-operands))
               (operand (funcall (elt operand-constraints arg) cg
                                 (codegen (elt args arg) cg false
                                          non-trashy-regs (car c))
                                 (car c))))
          ;; if the operand register didn't actually get used
          ;; (e.g. because the subform was an immediate), put it aside
          (unless (operand-using-reg? operand (car c))
            (push (car c) unused-operand-regs))

          ;; record the actual operand to be used by the
          ;; define-codegen body
          (rplaca c operand)

          ;; remove the no-longer-available register
          (set! non-trashy-regs (cdr non-trashy-regs))))

      ;; reload trashy arg results from stack
      (dolist (arg (reverse trashy-args))
        (emit-frame-pop cg (elt regs arg)))

      ;; track unused-operand-regs properly.  these might not be used,
      ;; but still need to go into spare regs, so that their values
      ;; are not seen by the GC.
      (unless (null? unused-operand-regs)
        (set! output-operands (nconc output-operands unused-operand-regs)))

      output-operands)))

(define (reg-operand-constraint cg operand reg)
  (emit-mov-maybe cg operand reg)
  reg)

(define (fixed-reg-operand-constraint cg operand reg)
  (emit-mov-maybe cg operand reg)
  reg)

(define (move-to-position l index item)
   (if (= 0 index)
      (cons item (remove item l))
      (let* ((l2 (delete item (copy-list l)))
             (pre (nthcdr (1- index) l2)))
        (rplacd pre (cons item (cdr pre)))
        l2)))

(defmacro (define-operator template options . body)
  (options-bind ((temp-regs ())
                 (tail-form false)
                 (temp-fixed-regs ()))
                options
    ;; define how to generate code for an operator
    (let* ((name (car template))
           (params (mapfor (p (cdr template)) (if (pair? p) (first p) p)))
           (param-specs (mapfor (p (cdr template))
                          (if (pair? p) p (list p 'reg))))
           (param-names (mapfor (ps param-specs) (first ps)))
           (have-fixed-regs (or (not (null? temp-fixed-regs))
                                (findfor (ps param-specs)
                                  (eq? 'fixed-reg (second ps)))))
           (outpos (and (not tail-form)
                        (let* ((out (last-elem body)))
                          (and (symbol? out) (position out params)))))
           (operand-constraints-name
                                 (compound-symbol name "-operand-constraints"))
           (registers-name (compound-symbol name "-registers"))
           (define-reg-use-name (if tail-form
                                    'define-reg-use-discarding
                                    'define-reg-use))
           (define-codegen-name (if tail-form
                                    'define-codegen-discarding
                                    'define-codegen)))
      (quasiquote (definitions
        ;; The operand-constraints for an operator is a list of
        ;; functions, each of which converts a general machine operand
        ;; (immediate, register or memory) into a form suitable for the
        ;; corresponding operand of the operation.
        (define (unquote operand-constraints-name)
          (list (unquote-splicing
            (mapfor (ps param-specs)
              (list 'function (compound-symbol (second ps)
                                               "-operand-constraint"))))))

        ;; For an operator with fixed-regs operands, we need a register
        ;; list that makes sure the right operands end up in the right
        ;; registers.
        (unquote-splicing (if (not have-fixed-regs) () (quasiquote (
          (define (unquote registers-name)
            (make-registers-from-template
              (list (unquote-splicing (mapfor (ps param-specs)
                                        (if (eq? 'fixed-reg (second ps))
                                            (third ps)
                                            false)))
                    (unquote-splicing temp-fixed-regs))
              general-registers))))))

        ((unquote define-reg-use-name) ((unquote name) attrs
                                        (unquote-splicing params))
          (unquote (cond (have-fixed-regs
                          '(begin (operator-args-reg-use form)
                                  general-register-count))
                         (tail-form
                          '(begin (operator-args-reg-use form)
                                  0))
                         (true
                           (quasiquote (max (operator-args-reg-use form)
                                            (unquote (+ (length param-specs)
                                                      (length temp-regs)))))))))

        (define-codegen ((unquote name) attrs (unquote-splicing params))
          ;; manipulate the register list as required
          (unquote
            (cond (have-fixed-regs
                   ;; if we have fixed regs, we need to use the special
                   ;; register list
                   (quasiquote (set! regs (unquote registers-name))))
                  (outpos
                   ;; shuffle regs so that the result reg corresponds to
                   ;; the output parameter
                   (quasiquote
                     (set! regs (move-to-position regs (unquote outpos) reg))))
                  (true
                   (begin))))

          (bind ((unquote-splicing param-names)
                 (unquote-splicing (mapfor (r temp-fixed-regs) (gensym)))
                 (unquote-splicing temp-regs)
                 . spare-regs)
                (operator-args-codegen form cg regs
                                       (unquote operand-constraints-name))
            (let* ((result reg))
              (unquote-splicing body)))))))))

(defmacro (define-cc-operator template options . body)
  ;; define how to generate code for an operator that is free of
  ;; side-effects and produces its result in a condition code
  (let* ((name (car template))
         (params (mapfor (p (cdr template)) (if (pair? p) (first p) p)))
         (param-specs (mapfor (p (cdr template))
                        (if (pair? p) p (list p 'reg))))
         (param-names (mapfor (ps param-specs) (first ps)))
         (param-operand-constraints
           (mapfor (p (cdr template)) (if (pair? p) (second p) 'reg)))
         (params-count (length params))
         (operand-constraints-name
           (compound-symbol name "-operand-constraints")))
    (quasiquote (definitions
      (define (unquote operand-constraints-name)
        (list (unquote-splicing
          (mapfor (ps param-specs)
            (list 'function (compound-symbol (second ps)
                                             "-operand-constraint"))))))

      (define-reg-use ((unquote name) attrs (unquote-splicing params))
        ;; converting from a CC to a reg value needs an extra register
        ;; over the body
        (max (unquote (1+ params-count)) (operator-args-reg-use form)))

      (define-codegen ((unquote name) attrs (unquote-splicing param-names))
        (set! regs (move-to-position regs (unquote params-count) reg))
        (bind ((unquote-splicing param-names) result . spare-regs)
              (operator-args-codegen form cg regs
                                     (unquote operand-constraints-name))
          (emit-prepare-convert-cc-value cg reg)
          (emit-convert-cc-value cg (begin (unquote-splicing body)) reg)
          reg))

      (define-reg-use-conditional ((unquote name) attrs
                                   (unquote-splicing param-names))
        (max (unquote params-count) (operator-args-reg-use form)))

      (define-codegen-conditional ((unquote name) attrs
                                   (unquote-splicing param-names))
        (bind ((unquote-splicing param-names) . spare-regs)
              (operator-args-codegen form cg regs
                                     (unquote operand-constraints-name))
          (let* ((cc (begin (unquote-splicing body))))
            (emit-smart-branch cg cc out-frame-base tlabel flabel))))))))


(define-reg-use-conditional (quote attrs) 0)
(define-codegen-conditional (quote attrs)
  (emit-reset-frame-base cg out-frame-base)
  (emit-smart-jump cg (if (quote-false? form) flabel tlabel)))

(define-reg-use (fill-closure attrs closure . refs)
  (max (reg-use closure) (1+ (max$ 0 (mapfor (ref refs) (reg-use ref))))))

(define-codegen (fill-closure attrs closure . refs)
  (let* ((closure-reg (first regs))
         (ref-reg (second regs))
         (index 0))
    (codegen-into-reg closure cg false regs closure-reg)
    (dolist (ref refs)
      (codegen-into-reg ref cg false (cdr regs) ref-reg)
      (emit-store-into-closure cg closure-reg index ref-reg)
      (set! index (1+ index)))
    closure-reg))

(define-reg-use (call attrs . args)
  (dolist (arg args) (reg-use arg))
  general-register-count)

(define-reg-use-discarding ((tail-call varargs-tail-call) attrs . args)
  (dolist (arg args) (reg-use arg))
  general-register-count)

(define (codegen-call-args cg func args)
  (dolist (arg (reverse args))
    (emit-frame-push cg (codegen arg cg false general-registers
                                 (first general-registers))))
  (when (func-needs-closure? func)
    (emit-mov-maybe cg (codegen func cg false general-registers
                                (first general-registers)) %closure)))
