;; codegen emits the code for the form.
(define-walker codegen (cg out-frame-base regs reg))
(define (codegen-recurse form cg out-frame-base regs reg)
  (error "codegen on unknown form ~S" (car form)))

;; reg-use returns the number of registers needed for the code
;; generated by codegen.
;;
;; The result should not be greater than general-register-count.
(define-walker reg-use ())
(define (reg-use-recurse form)
  (error "reg-use on unknown form ~S" (car form)))

;; codegen-discarding emits code to evaluate the form, in a context
;; where the resulting value is not used.
(define-walker codegen-discarding (cg out-frame-base regs))

;; reg-use-discarding returns the number of registers needed for the
;; code generated by codegen-discarding.
(define-walker reg-use-discarding ())

;; codegen-conditional emits code to evaluate the form, in a
;; conditional context.
(define-walker codegen-conditional (cg out-frame-base regs tlabel flabel))

;; reg-use-conditional returns the number of registers needed for the
;; code generated by codegen-conditional.
(define-walker reg-use-conditional ())

;;; codegen and reg-use fallbacks

(define (codegen-into-reg form cg out-frame-base regs reg)
  (emit-mov-maybe cg (codegen form cg out-frame-base regs reg) reg))

(define (reg-use-discarding-recurse form)
  (reg-use form))

(define (codegen-discarding-recurse form cg out-frame-base regs)
  (codegen form cg out-frame-base regs (if (null? regs) false (first regs))))

(define (reg-use-conditional-recurse form)
  (reg-use form))

(define (codegen-conditional-recurse form cg out-frame-base regs tlabel flabel)
  (let* ((reg (if (null? regs) false (first regs))))
    (emit-branch-on-operand cg (codegen form cg out-frame-base regs reg) reg
                            out-frame-base tlabel flabel)))

;;; Begin

(define (reg-use-begin forms max-ru reg-use-last)
  ;; work out the reg-use of forms, using reg-use-last to evaluate the
  ;; reg-use of the last form
  (if (null? (cdr forms))
      (max max-ru (funcall reg-use-last (car forms)))
      (reg-use-begin (cdr forms) (max max-ru (reg-use-discarding (car forms)))
                     reg-use-last)))

(define (codegen-begin-non-final cg forms regs)
  (if (null? (cdr forms))
      (begin
        (emit-comment-form cg (car forms))
        (car forms))
      (begin
        (emit-comment-form cg (car forms))
        (codegen-discarding (car forms) cg false regs)
        (codegen-begin-non-final cg (cdr forms) regs))))

(define-reg-use (begin varrecs . body)
  (reg-use-begin body 1 (function reg-use)))

;; We always attempt to reset the frame-base at the end of a begin.
;; Sometimes this won't do anything, because the last form in the
;; begin will have taken care of it (e.g. a nested begin).  But
;; checking there means that most forms can ignore out-frame-base

(define-codegen (begin varrecs . body)
  (unless out-frame-base (set! out-frame-base (codegen-frame-base cg)))
  ;; we make sure that the result goes into a register, because any
  ;; operand that depends on the frame-base might no longer be valid
  ;; if we alter the frame-base
  (codegen-into-reg (codegen-begin-non-final cg body regs) cg out-frame-base
                    regs (first regs))
  (emit-reset-frame-base cg out-frame-base)
  (first regs))

(define-reg-use-discarding (begin varrecs . body)
  (reg-use-begin body 0 (function reg-use-discarding)))

(define-codegen-discarding (begin varrecs . body)
  (unless out-frame-base (set! out-frame-base (codegen-frame-base cg)))
  (codegen-discarding (codegen-begin-non-final cg body regs)
                      cg out-frame-base regs)
  (emit-reset-frame-base cg out-frame-base))

(define-reg-use-conditional (begin varrecs . body)
  (reg-use-begin body 0 (function reg-use-conditional)))

(define-codegen-conditional (begin varrecs . body)
  (unless out-frame-base (set! out-frame-base (codegen-frame-base cg)))
  (codegen-conditional (codegen-begin-non-final cg body regs)
                       cg out-frame-base regs tlabel flabel)
  ;; codegen-conditional should always handle the reset-frame-base
  )

;;; If

(define (codegen-if test then else cg out-frame-base regs codegen-clause)
  (let* ((l1 (gen-label))
         (l2 (gen-label))
         (l3 (gen-label)))
    (codegen-conditional test cg false regs l1 l2)
    (emit-smart-label cg l1)
    (with-saved-frame-base cg
      (emit-comment-form cg then)
      (funcall codegen-clause then)
      (emit-reset-frame-base cg out-frame-base))
    (emit-smart-jump cg l3)
    (emit-smart-label cg l2)
    (emit-comment-form cg else)
    (funcall codegen-clause else)
    (emit-reset-frame-base cg out-frame-base)
    (emit-smart-label cg l3)))

(define-reg-use (if attrs test then else)
  (max 1 (reg-use-conditional test) (reg-use then) (reg-use else)))

(define-codegen (if attrs test then else)
  (codegen-if test then else cg out-frame-base regs
            (lambda (form) (codegen-into-reg form cg out-frame-base regs reg)))
  reg)

(define-reg-use-discarding (if attrs test then else)
  (max (reg-use-conditional test) (reg-use-discarding then)
       (reg-use-discarding else)))

(define-codegen-discarding (if attrs test then else)
  (codegen-if test then else cg out-frame-base regs
              (lambda (form) (codegen-discarding form cg out-frame-base regs))))

(define-reg-use-conditional (if attrs test then else)
  (max (reg-use-conditional test) (reg-use-conditional then)
       (reg-use-conditional else)))

(define-codegen-conditional (if attrs test then else)
  (codegen-if test then else cg out-frame-base regs
    (lambda (form)
      (codegen-conditional form cg out-frame-base regs tlabel flabel))))

;;; Operator support

(define (operator-args-reg-use form)
  ;; Find the number of registers required for evaluation of the
  ;; arguments of an operator
  (let* ((count 0)
         ;; calcuate the reg-use of each argument, and sort them into
         ;; descending order.  This is the basis for the order we will
         ;; evaluate them in operator-args-codegen
         (args-ru (sort (mapfor (arg (cddr form))
                          (let* ((index count))
                            (set! count (1+ count))
                            (cons index (reg-use arg))))
                        (lambda (a b) (> (cdr a) (cdr b)))))
         (trashy-args ())
         (non-trashy-args ())
         (intermediates 0)
         (max-ru 0))
    ;; We now proceed through the arguments, clasifying them into
    ;; non-trashy-args (whose results can be kept in registers) and
    ;; trashy-args (whose results must be put on the stack).
    ;; intermediates holds the number of registers needed to hold
    ;; intermediate results during the evaluation of each argument.
    (dolist (arg-ru args-ru)
      ;; The number of registers needed to evaluate this argument
      ;; without spilling is the number of registers used by the
      ;; argument itself, plus any intermediates.
      (let* ((ru (+ intermediates (cdr arg-ru))))
        (when (> ru max-ru) (set! max-ru ru))
        (if (> ru general-register-count)
          (begin
            ;; we cannot satisfy the register requirements of the
            ;; argument while holding the intermediates, so classify
            ;; it as trashy
            (rplacd arg-ru trashy-args)
            (set! trashy-args arg-ru))
          (begin
            (rplacd arg-ru non-trashy-args)
            (set! non-trashy-args arg-ru)
            (set! intermediates (1+ intermediates))))))

    ;; Stash the trashy-args and non-trashy-args lists for
    ;; operator-args-codegen.  Note that they are left in descending
    ;; order of reg-use, i.e. the reverse of the order of evaluation.
    (rplaca (cdr form) (list* (cons 'trashy-args trashy-args)
                              (cons 'non-trashy-args non-trashy-args)
                              (cadr form)))

    ;; This result doesn't include the point where all the operands
    ;; are potentially reloaded into registers, ready for the operator
    ;; body.  The caller should take care of that.
    (min max-ru general-register-count)))

(define (codegen-non-trashy-args form cg regs operand-constraints)
  (let* ((args (cddr form))

         (result-regs ())
         (output-operands (copy-list regs))
         (unused-operand-regs ()))
    (labels ((for-nt-args (non-trashy-args available-regs)
               (if (null? non-trashy-args)
                   (nconc result-regs (delete false available-regs))
                   (let* ((arg (car non-trashy-args)))
                     ;; Move the regs that will take the results of
                     ;; non-trashy-args to the start of available-regs
                     ;; in the correct order (i.e. the first in
                     ;; available-regs will take the result of the
                     ;; first non-trashy-arg to be evaluated).  Note
                     ;; that operator-args-reg-use left the
                     ;; non-trashy-args list in reverse order of
                     ;; evaluation,
                     (let* ((c (nthcdr arg available-regs)))
                       (push (car c) result-regs)
                       (rplaca c false))

                     (set! available-regs
                           (for-nt-args (cdr non-trashy-args) available-regs))

                     ;; Now generate code for non-trashy args.
                     (let* ((c (nthcdr arg output-operands))
                            (reg (car c))
                            (operand (codegen (elt args arg) cg false
                                              available-regs reg)))
                       ;; If the result of evaluating the argument
                       ;; doesn't meet the operand constraint, move it
                       ;; into the allocated register.
                       (unless (funcall (funcall operand-constraints arg)
                                        operand)
                         (emit-mov-maybe cg operand reg)
                         (set! operand reg))

                       ;; Results are not necessaily produced as
                       ;; register operands (e.g. an arg can produce
                       ;; memory or immediate operands).  If the
                       ;; operand register didn't actually get used,
                       ;; put it aside.
                       (unless (operand-using-reg? operand reg)
                         (push reg unused-operand-regs))

                       ;; Replace the corresponding entry in
                       ;; output-operands with the actual operand.
                       (rplaca c operand)

                       (cdr available-regs))))))
      (for-nt-args (form-attr form 'non-trashy-args) (copy-list regs)))

    ;; Track unused-operand-regs properly.  Although they are not
    ;; used, they still need to end up in spare regs during GC ops,
    ;; so that their values are not seen by the GC.  So they need to
    ;; be present in output-operands.
    (if (null? unused-operand-regs)
        output-operands
        (nconc output-operands unused-operand-regs))))

(define (operator-args-codegen form cg regs operand-constraints)
  ;; Generate the code to evaluate the arguments of an operator
  (let* ((args (cddr form)))
    (when (> (length args) (length regs))
      (error "more operator arguments than available registers in ~S"
             (comment-form form)))

    (labels ((for-trashy-args (trashy-args)
               (if (null? trashy-args)
                   (codegen-non-trashy-args form cg regs
                                            (lambda (arg)
                                              (elt operand-constraints arg)))
                   (begin
                     ;; Evaluate a trashy-arg, saving its result on the
                     ;; stack.
                     (emit-frame-spill cg (codegen (elt args (car trashy-args))
                                                   cg false regs (first regs))
                                       (first regs))

                     (let* ((output-operands
                              (for-trashy-args (cdr trashy-args))))
                       ;; And after we've done everything else, reload it
                       (emit-frame-pop cg (elt regs (car trashy-args)))
                       output-operands)))))
      (for-trashy-args (form-attr form 'trashy-args)))))

;; For a "reg" operand, need to ensure that the operand is in the
;; allocated register.
(define (reg-operand-constraint operand) false)

;; For a "fixed-reg" operand, need to ensure the the operand is in the
;; allocated register, which will always be the specified register.
(define (fixed-reg-operand-constraint operand) false)

(define (move-to-position l index item)
   (if (= 0 index)
      (cons item (remove item l))
      (let* ((l2 (delete item (copy-list l)))
             (pre (nthcdr (1- index) l2)))
        (rplacd pre (cons item (cdr pre)))
        l2)))

(defmacro (define-operator template options . body)
  (if (and (null? (cdr template)) (null? options))
      ;; A simple no-args operator.  We don't need the full codegen
      ;; machinery for this.
      (quasiquote (definitions
        (define-reg-use ((unquote (car template)) attrs) 1)

        (define-codegen ((unquote (car template)) attrs)
          (let* ((result reg)
                 (spare-regs regs))
            . (unquote body)))))
      (options-bind ((temp-regs ())
                     (tail-form false)
                     (temp-fixed-regs ()))
                    options
        ;; define how to generate code for an operator
        (let* ((name (car template))
               (params (mapfor (p (cdr template)) (if (pair? p) (first p) p)))
               (param-specs (mapfor (p (cdr template))
                                    (if (pair? p) p (list p 'reg))))
               (param-names (mapfor (ps param-specs) (first ps)))
               (have-fixed-regs (or (not (null? temp-fixed-regs))
                                    (findfor (ps param-specs)
                                             (eq? 'fixed-reg (second ps)))))
               (outpos (and (not tail-form)
                            (let* ((out (last-elem body)))
                              (and (symbol? out) (position out params)))))
               (operand-constraints-name
                                 (compound-symbol name "-operand-constraints"))
               (registers-name (compound-symbol name "-registers")))
          (quasiquote (definitions
            ;; The operand-constraints for an operator is a list of
            ;; functions, each of which converts a general machine operand
            ;; (immediate, register or memory) into a form suitable for the
            ;; corresponding operand of the operation.
            (define (unquote operand-constraints-name)
              (list . (unquote
                     (mapfor (ps param-specs)
                             (list 'function (compound-symbol (second ps)
                                                     "-operand-constraint"))))))

            ;; For an operator with fixed-regs operands, we need a register
            ;; list that makes sure the right operands end up in the right
            ;; registers.
            (unquote (if (not have-fixed-regs) '(definitions) (quasiquote
              (define (unquote registers-name)
                (make-registers-from-template
                  (list (unquote-splicing (mapfor (ps param-specs)
                                            (if (eq? 'fixed-reg (second ps))
                                                (third ps)
                                                false)))
                        . (unquote temp-fixed-regs))
                  general-registers)))))

            ((unquote (if tail-form
                          'define-reg-use-discarding
                          'define-reg-use))
               ((unquote name) attrs . (unquote params))
             (unquote (cond (have-fixed-regs
                             '(begin (operator-args-reg-use form)
                               general-register-count))
                            (tail-form
                             '(begin (operator-args-reg-use form)
                               0))
                            (true
                             ;; We always need at least one register for
                             ;; the result reg
                             (quasiquote (max 1
                                              (operator-args-reg-use form)
                                              (unquote (+ (length param-specs)
                                                      (length temp-regs)))))))))

            ((unquote (if tail-form 'define-codegen-discarding
                          'define-codegen))
             ((unquote name) attrs . (unquote params))
             ;; manipulate the register list as required
             (unquote
               (cond (have-fixed-regs
                      ;; if we have fixed regs, we need to use the special
                      ;; register list
                      (quasiquote (set! regs (unquote registers-name))))
                     (outpos
                      ;; shuffle regs so that the result reg corresponds to
                      ;; the output parameter
                      (quasiquote (set! regs
                                 (move-to-position regs (unquote outpos) reg))))
                     (true
                      (begin))))

             (bind ((unquote-splicing param-names)
                    (unquote-splicing (mapfor (r temp-fixed-regs) (gensym)))
                    (unquote-splicing temp-regs)
                    . spare-regs)
                   (operator-args-codegen form cg regs
                                          (unquote operand-constraints-name))
               (let* (unquote (if tail-form () '((result reg))))
                 . (unquote body))))))))))

(defmacro (define-cc-operator template options . body)
  ;; define how to generate code for an operator that is free of
  ;; side-effects and produces its result in a condition code
  (let* ((name (car template))
         (params (mapfor (p (cdr template)) (if (pair? p) (first p) p)))
         (param-specs (mapfor (p (cdr template))
                        (if (pair? p) p (list p 'reg))))
         (param-names (mapfor (ps param-specs) (first ps)))
         (param-operand-constraints
           (mapfor (p (cdr template)) (if (pair? p) (second p) 'reg)))
         (params-count (length params))
         (operand-constraints-name
           (compound-symbol name "-operand-constraints")))
    (quasiquote (definitions
      (define (unquote operand-constraints-name)
        (list . (unquote
          (mapfor (ps param-specs)
            (list 'function (compound-symbol (second ps)
                                             "-operand-constraint"))))))

      (define-reg-use ((unquote name) attrs . (unquote params))
        ;; converting from a CC to a reg value needs an extra register
        ;; over the body
        (max (unquote (1+ params-count)) (operator-args-reg-use form)))

      (define-codegen ((unquote name) attrs . (unquote param-names))
        (set! regs (move-to-position regs (unquote params-count) reg))
        (bind ((unquote-splicing param-names) result . spare-regs)
              (operator-args-codegen form cg regs
                                     (unquote operand-constraints-name))
          (emit-prepare-convert-cc-value cg reg)
          (emit-convert-cc-value cg (begin . (unquote body)) reg)
          reg))

      (define-reg-use-conditional ((unquote name) attrs
                                   . (unquote param-names))
        (max (unquote params-count) (operator-args-reg-use form)))

      (define-codegen-conditional ((unquote name) attrs
                                   . (unquote param-names))
        (bind ((unquote-splicing param-names) . spare-regs)
              (operator-args-codegen form cg regs
                                     (unquote operand-constraints-name))
          (let* ((cc (begin . (unquote body))))
            (emit-smart-branch cg cc out-frame-base tlabel flabel))))))))


(define-reg-use-conditional (quote attrs) 0)
(define-codegen-conditional (quote attrs)
  (emit-reset-frame-base cg out-frame-base)
  (emit-smart-jump cg (if (quote-false? form) flabel tlabel)))

(define-reg-use (lambda attrs closure . vals)
  (max (reg-use closure) (1+ (max$ 0 (mapfor (val vals) (reg-use val))))))

(define-codegen (lambda attrs closure . vals)
  (codegen-lambda-todo cg form)
  (let* ((closure-reg (first regs))
         (val-reg (second regs))
         (index 0))
    (codegen-into-reg closure cg false regs closure-reg)
    (dolist (val vals)
      (codegen-into-reg val cg false (cdr regs) val-reg)
      (emit-store-into-closure cg closure-reg index val-reg)
      (set! index (1+ index)))
    closure-reg))

;;; codegen functions called from outside this file

(define (trashy-codegen form cg out-frame-base)
  (codegen form cg out-frame-base general-registers (first general-registers)))

(define (trashy-codegen-into-reg form cg out-frame-base reg)
  (emit-mov-maybe cg (codegen form cg out-frame-base general-registers reg)
                  reg))

(define (trashy-codegen-discarding form cg out-frame-base)
  ;; This is called for codegen of program fragments, so we need to do
  ;; the reg-use pass
  (reg-use-discarding form)
  (codegen-discarding form cg out-frame-base general-registers))

(defmacro (define-trashy-codegen template options . body)
  (options-bind ((tail-form false)) options
    (quasiquote (definitions
      ((unquote (if tail-form 'define-reg-use-discarding 'define-reg-use))
          (unquote template)
        (operator-args-reg-use form)
        general-register-count)

      ((unquote (if tail-form 'define-codegen-discarding 'define-codegen))
          (unquote template)
        . (unquote body))))))

;; Generate code to evaluate subforms in some general contexts,
;; e.g. tail calls, c-calls, etc.  Values can get pushed onto the
;; stack, so it might need to be followed by an reset-frame-base.
(define (trashy-codegen-subforms form cg regs operand-constraint)
  (let* ((args (cddr form)))
    ;; If the number of args is greater than the number of regs, then we
    ;; need to pad the regs list with false entries
    (when (> (length args) general-register-count)
      (let* ((padded (make-vector (length args) false)))
        (dolist (ntarg (form-attr form 'non-trashy-args))
          (vector-set! padded ntarg (car regs))
          (set! regs (cdr regs)))
        (set! regs (nconc (vector-to-list padded) regs))))

    (labels ((aux (trashy-args)
               (if (null? trashy-args)
                   (codegen-non-trashy-args form cg regs
                                            (lambda (arg) operand-constraint))
                   (begin
                     ;; Evaluate a trashy-arg, saving its result on the
                     ;; stack.
                     (emit-frame-push cg (codegen (elt args (car trashy-args))
                                                  cg false regs (first regs)))

                     (let* ((operand (frame-slot (codegen-frame-base cg)))
                            (output-operands (aux (cdr trashy-args))))
                       ;; Apply operand-constraint to the result on
                       ;; the stack
                       (unless (funcall operand-constraint operand)
                         (emit-mov-maybe cg operand (first regs))
                         (set! operand (first regs)))
                       (rplaca (nthcdr (car trashy-args) output-operands)
                               operand)
                       output-operands)))))
      (aux (form-attr form 'trashy-args)))))

(define (trashy-codegen-into-regs cg form regs)
  (trashy-codegen-subforms form cg regs (function reg-operand-constraint)))

;; An operand constraint that accepts anything.  But for registers, we
;; still need to ensure the the operand is in the allocated register.
(define (any-operand-constraint op)
  (not (register? op)))

(define (trashy-codegen-general cg form)
  (trashy-codegen-subforms form cg general-registers
                           (function any-operand-constraint)))

(define-reg-use (call attrs . args)
  (dolist (arg args) (reg-use arg))
  general-register-count)

(define-reg-use-discarding (varargs-tail-call attrs . args)
  (dolist (arg args) (reg-use arg))
  general-register-count)
