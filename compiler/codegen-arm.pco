;;; ARMv5 code generation

;; Condition codes

(defconstant cc-eq 0)
(defconstant cc-ne 1)
(defconstant cc-gt 2)
(defconstant cc-le 3)
(defconstant cc-ge 4)
(defconstant cc-lt 5)

(define cc-insn-suffixes (vector "eq" "ne" "gt" "le" "ge" "lt"))

(define (cc-insn-suffix cc)
  (vector-ref cc-insn-suffixes cc))

(define (negate-cc cc)
  (logxor cc 1))

;;; Operand types

(define (register? x) (vector? x))
(define (immediate? x) (or (number? x) (string? x)))
(define (immediate8? x) (and (number? x) (= 0 (logand x -256))))
(define (immediate12? x) (and (number? x) (= 0 (logand (abs x) -4096))))

(defmacro (reg-asm-operand reg)
  (list 'register-variant reg 0))

(define (asm-operand x)
  (cond ((number? x) (format "#~D" x))
        ((string? x) x)
        ((vector? x) (reg-asm-operand x))
        (true (error "strange operand ~S" x))))

(define (operand-using-reg? o r)
  (eq? o r))

(define (reg-imm8-operand-constraint cg operand reg)
  (if (immediate8? operand)
      operand
      (begin
        (emit-mov-maybe cg operand reg)
        reg)))

(define (reg-imm12-operand-constraint cg operand reg)
  (if (immediate12? operand)
      operand
      (begin
        (emit-mov-maybe cg operand reg)
        reg)))

(define (reg-imm-operand-constraint cg operand reg)
  (if (immediate? operand)
      operand
      (begin
        (emit-mov-maybe cg operand reg)
        reg)))

(define (shift-expr shift)
  (cond ((= shift 0) "")
        ((> shift 0) (format ", asr #~D" shift))
        (true (error "unexpected shoft ~D" shift))))

(define (scale-number-expr scale)
  (shift-expr (- number-tag-bits scale)))

;;; Assembly bits

(define (multi-operand regs)
  (if (null? regs) "{}"
      (labels ((pieces (regs)
                 (if (null? (cdr regs))
                     (list (reg-asm-operand (car regs)) "}")
                     (list* (reg-asm-operand (car regs)) ", "
                            (pieces (cdr regs))))))
        (string-flatten (cons "{" (pieces regs))))))

(define (emit-literal cg lit)
  (emit cg ".word ~A" lit))

(define (emit-align cg scale)
  (emit cg ".align ~D" scale))

;; Ok, ARM requires us to do a .ltorg every so often to tell the
;; assembler to flush the literal pool.  So we handle that here.

(define instructions-since-pool 0)

(define (emit-ltorg cg)
  (unless (= instructions-since-pool 0)
    (emit-without-flushing ".ltorg")
    (set! instructions-since-pool 0)))

(define (check-instructions-since-pool cg)
  (when (> (set! instructions-since-pool (1+ instructions-since-pool)) 1000)
    (let* ((label (gen-label)))
      (emit-smart-jump cg label)
      (flush-labels-and-jumps cg)
      (emit-smart-label cg label))))

(defmacro (emiti cg template . args)
  (quasiquote
    (begin
      (check-instructions-since-pool (unquote cg))
      (emit (unquote cg) (unquote template) . (unquote args)))))

(define (emit-push cg reg)
  (emiti cg "str ~A, [sp, #-4]!" (reg-asm-operand reg)))

(define (emit-pop cg reg)
  (emiti cg "ldr ~A, [sp], #4" (reg-asm-operand reg)))

(define (emit-mov cg src dest)
  (emiti cg "mov ~A, ~A" (reg-asm-operand dest) (reg-asm-operand src)))

;;; Used by codegen strategies

(define (emit-mov-maybe cg src dest)
  (cond ((register? src)
         (unless (eq? src dest) (emit-mov cg src dest)))
        ((immediate8? src)
         (emiti cg "mov ~A, #~D" (reg-asm-operand dest) src))
        (true
         (emiti cg "ldr ~A, =~A" (reg-asm-operand dest) src))))

(define (emit-branch cg cc label)
  (emit-without-flushing "b~A ~A" (cc-insn-suffix cc) label))

(define (emit-jump cg label)
  (emit-without-flushing "b ~A" label)
  (emit-ltorg cg))

(define (emit-prepare-convert-cc-value cg reg)
  (emiti cg "mov ~A, #~A" (reg-asm-operand reg) false-representation))

(define (emit-convert-cc-value cg cc reg)
  (emiti cg "mov~A ~A, #~A" (cc-insn-suffix cc) (reg-asm-operand reg)
         true-representation))

(define (emit-branch-on-operand cg reg out-frame-base tlabel flabel)
  (emiti cg "cmp ~A, #~A" (reg-asm-operand reg) false-representation)
  (emit-smart-branch cg cc-ne out-frame-base tlabel flabel))

(define (prepare-for-call cg func nargs)
  (let* ((attrs (func-lambda-attrs func)))
    (if attrs
        (let* ((labels (attr-ref attrs 'labels)))
          (check-call-nargs attrs nargs)
          (if (null? (cdr labels))
              (begin
                (emiti cg "mov ~A, #~A" (reg-asm-operand %nargs)
                       (fixnum-representation nargs))
                (first labels))
              (second labels)))
        (begin
          (emiti cg "mov ~A, #~A" (reg-asm-operand %nargs)
                 (fixnum-representation nargs))
          false))))

(define (emit-function-call cg func nargs)
  (let* ((label (prepare-for-call cg func nargs)))
    (if label
        (emiti cg "bl ~A @ ~S" label (comment-form func))
        (begin
          (emiti cg "ldr r0, [~A, #-~D]" (reg-asm-operand %closure)
                 closure-tag)
          (emiti cg "mov lr, pc")
          (emiti cg "mov pc, r0")))))

(define (emit-function-jump cg func nargs)
  (let* ((label (prepare-for-call cg func nargs)))
    (if label
        (emiti cg "b ~A @ ~S" label (comment-form func))
        (emiti cg "ldr pc, [~A, #-~D]" (reg-asm-operand %closure) closure-tag))
    (emit-ltorg cg)))

(defmacro (define-tag-check name tag tag-bits)
  (quasiquote
    (define-cc-operator ((unquote name) val) ()
      (let* ((valreg (reg-asm-operand val)))
        (emiti cg "and ~A, ~A, #~D" valreg valreg
               (low-bits-mask (unquote tag-bits)))
        (emiti cg "cmp ~A, #~D" valreg (unquote tag)))
      cc-eq)))

;;; Helper init-mem function
;;;
;;; Init-mem functions are used by make-vec to clear the allocated
;;; memory.  The caller sets up %init-mem-count and %init-mem-val.

(define init-mem-variants (vector "init_mem_bytes" false "init_mem"))
(define str-variants (vector "strb" false "str"))
(define ldr-variants (vector "ldrb" false "ldr"))

(defconstant %init-mem-count (first general-registers))
(defconstant %init-mem-val (second general-registers))
(defconstant %init-mem-ptr (third general-registers))

(define (codegen-init-mem cg scale)
  (let* ((loop-label (gen-label))
         (name (vector-ref init-mem-variants scale))
         (count (reg-asm-operand %init-mem-count))
         (ptr (reg-asm-operand %init-mem-ptr)))
    (emit cg ".text")
    (emit cg ".globl ~A" name)
    (emit cg "~A:" name)

    ;; If %init-mem-count is zero, return straight away
    (emiti cg "cmp ~A, #0" count)
    (emiti cg "moveq pc, lr")

    (emiti cg "add ~A, ~A, #~D" ptr (reg-asm-operand %alloc) value-size)

    (emit-raw-label cg loop-label)
    (emiti cg "subs ~A, ~A, #1" count count)
    (emiti cg "~A ~A, [~A], #~D" (vector-ref str-variants scale)
           (reg-asm-operand %init-mem-val) ptr (ash 1 scale))
    (emiti cg "bne ~A" loop-label)

    (emiti cg "mov pc, lr")))

;;; C-callable program wrapper

(define (codegen-program program)
  (let* ((cg (make-codegen))
         (saved-regs (multi-operand (append c-callee-saved-regs (list %lr)))))
    (codegen-program-start cg program)

    (emit cg ".text")
    (emit cg ".globl lisp")
    (emit cg "lisp:")
    (emiti cg "stmfd sp!, ~A" saved-regs)

    ;; load register globals from the variables assigned by the C setup
    ;; code
    (let* ((temp (first general-registers)))
      (dolist (rglob register-globals)
        (access-global cg "ldr" (cdr rglob) (car rglob) temp)))

    (codegen-set-frame-base! cg 0)
    (codegen-body cg program 0)

    (emiti cg "ldmfd sp!, ~A" saved-regs)
    (emiti cg "mov pc, lr")

    (codegen-do-out-of-line cg)
    (emit cg ".size lisp, .-lisp")

    (codegen-program-end cg)))

;;; Stack layout:
;;;
;;; param N
;;; ...
;;; param 1
;;; param 0  <--- %sp + frame-base
;;; Return address
;;; %closure (if present)
;;; Local var 0
;;; ...
;;; Local var N
;;; in-progress param N
;;; in-progress param N-1
;;; ...
;;;
;;; Functions are called with the closure in %closure, arg-count in
;;; %nargs.  They return with the result in %funcres.

(define (emit-function-prologue cg)
  (codegen-set-frame-base! cg 0)
  (emit-frame-push cg %lr))

(define (stack-param-offset cg index)
  (* value-size (+ index (codegen-frame-base cg))))

(define (stack-return-offset cg)
  (stack-param-offset cg -1))

(define (stack-closure-offset cg)
  (stack-param-offset cg -2))

(define (stack-local-offset cg index)
  (* value-size (- (codegen-frame-base cg) index)))

(define (closure-slot-offset index)
  (- (* value-size (1+ index)) closure-tag))

(define (emit-reset-frame-base cg out-frame-base)
  (when out-frame-base
    (let* ((in-frame-base (codegen-frame-base cg)))
      (unless (= in-frame-base out-frame-base)
        (emiti cg "add sp, sp, #~D"
              (* value-size (- in-frame-base out-frame-base)))
        (codegen-set-frame-base! cg out-frame-base)))))

(define (emit-frame-push cg reg)
  (emit-push cg reg)
  (codegen-set-frame-base! cg (1+ (codegen-frame-base cg))))

(define (emit-frame-pop cg reg)
  (emit-pop cg reg)
  (codegen-set-frame-base! cg (1- (codegen-frame-base cg))))

(define (emit-frame-spill cg operand reg)
  (unless (register? operand)
    (emit-mov-maybe cg operand reg)
    (set! operand reg))
  (emit-frame-push cg operand))

;;; Function and closure bits

(define-tag-check function? closure-tag closure-tag-bits)

;; alloc-closure simply allocates space for the closure, it does not
;; initialize its contents.  This is because it will always be
;; enclosed by a lambda that does the initialization.
(define-operator (alloc-closure) ((temp-regs labelreg))
  (emit-alloc cg closure-tag-bits (* value-size (1+ (attr-ref attrs 'length)))
              value-scale (cons labelreg spare-regs))
  (emiti cg "ldr ~A, =~A" (reg-asm-operand labelreg) (attr-ref attrs 'label))
  (emiti cg "str ~A, [~A]" (reg-asm-operand labelreg) (reg-asm-operand %alloc))
  (emiti cg "add ~A, ~A, #~D" (reg-asm-operand result)
         (reg-asm-operand %alloc) closure-tag)
  result)

(define (emit-store-into-closure cg closure index val)
  (emiti cg "str ~A, [~A, #~D]" (reg-asm-operand val)
        (reg-asm-operand closure) (closure-slot-offset index)))

(define-operator (set-closure! closure val) ()
  (emit-store-into-closure cg closure (attr-ref attrs 'index) val)
  val)

(define-cc-operator (check-arg-count) ()
  cc-eq)

(define (emit-check-nargs cg nparams bad-nargs-label)
  (emiti cg "cmp ~A, #~A" (reg-asm-operand %nargs)
         (fixnum-representation nparams))
  (emit-branch cg cc-ne bad-nargs-label))

(define-operator (arg-count) () %nargs)

(define-operator (raw-args-base) ()
  (emiti cg "add ~A, sp, #~D" (reg-asm-operand result)
        (stack-param-offset cg 0))
  result)

(define-codegen (call attrs func . args)
  (with-saved-frame-base cg
    (codegen-call-args cg func args)
    (emit-function-call cg func (length args)))
  (emit-restore-%closure cg)
  %funcres)

(define-operator (return (retval fixed-reg %funcres)) (tail-form)
  (emiti cg "ldr lr, [sp, #~D]" (stack-return-offset cg))
  (emiti cg "add sp, sp, #~D" (stack-param-offset cg (attr-ref attrs 'nparams)))
  (emiti cg "mov pc, lr")
  (emit-ltorg cg)
  (codegen-function-tail cg out-frame-base))

(define-operator (varargs-return arg-count (retval fixed-reg %funcres))
                 (tail-form)
  (emiti cg "ldr lr, [sp, #~D]" (stack-return-offset cg))
  (emiti cg "add sp, sp, #~D" (stack-param-offset cg 0))
  (emiti cg "add sp, sp, ~A~A" (reg-asm-operand arg-count)
        (scale-number-expr value-scale))
  (emiti cg "mov pc, lr")
  (emit-ltorg cg)
  (codegen-function-tail cg out-frame-base))

(define (codegen-copy-stack cg dest-offset count regs)
  (cond ((= count 0)
         (emiti cg "add sp, sp, ~A" dest-offset))
        ((< count (length regs))
         (let* ((regs-operand (multi-operand (sublist regs 0 count))))
           (emiti cg "ldmia sp, ~A" regs-operand)
           (emiti cg "add sp, sp, ~A" dest-offset)
           (emiti cg "stmia sp, ~A" regs-operand)))
        (true
         (error "cowardly refusing big emit-copy-stack"))))

(define (codegen-tail-call cg func args out-arg-count out-param-offset regs)
  (emiti cg "ldr lr, [sp, #~D]" (stack-return-offset cg))
  (codegen-copy-stack cg out-param-offset out-arg-count regs)
  (emit-function-jump cg func out-arg-count))

(define-codegen-discarding (tail-call attrs func . args)
  (codegen-call-args cg func args)
  (let* ((in-arg-count (attr-ref attrs 'nparams))
         (out-arg-count (length args)))
    (codegen-tail-call cg func args out-arg-count
                       (asm-operand (stack-param-offset cg (- in-arg-count
                                                               out-arg-count)))
                       general-registers)
    (emit-ltorg cg)
    (codegen-function-tail cg out-frame-base)))

(define-codegen-discarding (varargs-tail-call attrs arg-count func . args)
  (codegen-call-args cg func args)
  (let* ((out-arg-count (length args))
         (out-param-offset-reg (first general-registers))
         (out-param-offset (reg-asm-operand out-param-offset-reg)))
    (trashy-codegen-into-reg arg-count cg false out-param-offset-reg)
    (emiti cg "mov ~A, ~A~A" out-param-offset out-param-offset
          (scale-number-expr value-scale))
    (emiti cg "add ~A, ~A, #~D" out-param-offset out-param-offset
          (stack-param-offset cg (- out-arg-count)))
    (codegen-tail-call cg func args out-arg-count out-param-offset
                       (cdr general-registers))
    (emit-ltorg cg)
    (codegen-function-tail cg out-frame-base)))

(define (emit-restore-%closure cg)
  (when (codegen-have-closure cg)
    (emiti cg "ldr ~A, [sp, #~D]" (reg-asm-operand %closure)
          (stack-closure-offset cg))))

;;; Apply support

(define-operator (raw-jump-with-arg-space before-arg-count after-arg-count
                                          bodyfunc)
                 (tail-form (temp-regs retaddr))
  (unless (eq? bodyfunc %closure) (emit-mov cg bodyfunc %closure))
  (emiti cg "ldr lr, [sp, #~D]" (stack-return-offset cg))
  (emiti cg "add sp, sp, #~D" (stack-param-offset cg 0))
  (emiti cg "add sp, sp, ~A~A" (reg-asm-operand before-arg-count)
        (scale-number-expr value-scale))
  (emiti cg "sub sp, sp, ~A~A" (reg-asm-operand after-arg-count)
        (scale-number-expr value-scale))
  (emit-function-jump cg (fifth form) 0)
  (emit-ltorg cg)
  (codegen-function-tail cg out-frame-base))

(define-operator (raw-apply-jump func (arg-count fixed-reg %nargs)) (tail-form)
  (unless (eq? func %closure) (emit-mov cg func %closure))
  (emiti cg "ldr lr, [sp, #~D]" (stack-return-offset cg))
  (emiti cg "add sp, sp, #~D" (stack-param-offset cg 0))
  (emiti cg "ldr pc, [~A, #-~D]" (reg-asm-operand %closure) closure-tag)
  (emit-ltorg cg)
  (codegen-function-tail cg out-frame-base))

;;; Variables

(define (access-global cg insn reg name tempreg)
  (set! tempreg (reg-asm-operand tempreg))
  (emiti cg "ldr ~A, =~A" tempreg
         (if (string? name) name (subject-language-symbol-name name)))
  (emiti cg "~A ~A, [~A]" insn (reg-asm-operand reg) tempreg))

(define (access-varrec cg varrec insn reg tempreg)
  (let* ((mode (varrec-mode varrec)))
    (cond ((eq? mode 'top-level)
           (access-global cg insn reg (varrec-index varrec) tempreg))
          ((not (eq? mode 'self))
           (let* ((base-reg %sp)
                  (offset
                   (cond ((eq? mode 'closure)
                          (set! base-reg %closure)
                          (closure-slot-offset (varrec-index varrec)))
                         ((eq? mode 'param)
                          (stack-param-offset cg (varrec-index varrec)))
                         ((eq? mode 'local)
                          (stack-local-offset cg (varrec-index varrec)))
                         (true (error "strange variable mode ~S" mode)))))
             (emiti cg "~A ~A, [~A, #~D]" insn (reg-asm-operand reg)
                   (reg-asm-operand base-reg) offset)))
          (true ; (eq? mode 'self)
           ;; we only need to read such variables
           (emiti cg "mov ~A, ~A" (reg-asm-operand reg)
                  (reg-asm-operand %closure))))))

(define-operator (define val) ()
  (emit-frame-push cg val)
  (varrec-set-index! (attr-ref attrs 'varrec) (codegen-frame-base cg))
  val)

(define-operator (set! val) ((temp-regs temp))
  (access-varrec cg (attr-ref attrs 'varrec) "str" val temp)
  val)

(define-operator (ref) ()
  (access-varrec cg (attr-ref attrs 'varrec) "ldr" result result)
  result)

;;; Comparisons

(defmacro (define-cmp-operator name cc)
  (quasiquote (define-cc-operator ((unquote name) a (b reg-imm8)) ()
                (emiti cg "cmp ~A, ~A" (reg-asm-operand a) (asm-operand b))
                (unquote cc))))

(define-cmp-operator eq? cc-eq)
(define-cmp-operator = cc-eq)
(define-cmp-operator /= cc-ne)
(define-cmp-operator > cc-gt)
(define-cmp-operator >= cc-ge)
(define-cmp-operator < cc-lt)
(define-cmp-operator <= cc-le)

;;; Numbers

(define-tag-check number? number-tag number-tag-bits)

(defmacro (define-simple-number-operator name insn)
  (quasiquote
    (define-operator ((unquote name) a (b reg-imm8)) ()
      (emiti cg (unquote (string-concat insn " ~A, ~A, ~A"))
             (reg-asm-operand result) (reg-asm-operand a) (asm-operand b))
      result)))

(define-simple-number-operator + "add")
(define-simple-number-operator - "sub")
(define-simple-number-operator logand "and")
(define-simple-number-operator logior "orr")
(define-simple-number-operator logxor "eor")

(define-operator (negate a) ()
  (emiti cg "rsb ~A, ~A, #0" (reg-asm-operand result) (reg-asm-operand a))
  result)

(define-operator (* a b) ((temp-regs temp))
  ;; early versions of the ARM architecture (pre-v6) suggest that the
  ;; operands of mul shouldn't be the same as the destination
  (emiti cg "mov ~A, ~A, asr #~D" (reg-asm-operand temp) (reg-asm-operand a)
        number-tag-bits)
  (emiti cg "mul ~A, ~A, ~A" (reg-asm-operand result) (reg-asm-operand temp)
        (reg-asm-operand b))
  result)

(define-trashy-codegen (truncate attrs a b)
  (trashy-codegen-into-regs cg (list a b) c-call-arg-regs)
  (emit-c-call cg "__aeabi_idiv")
  (emiti cg "mov r0, r0, asl #~D" number-tag-bits)
  %r0)

(define-trashy-codegen (rem attrs a b)
  (trashy-codegen-into-regs cg (list a b) c-call-arg-regs)
  (emit-c-call cg "__aeabi_idivmod")
  %r1)

(define-operator (ash-imm n) ()
  (let* ((shift (attr-ref attrs 'shift)))
    (if (> shift 0)
        (emiti cg "mov ~A, ~A, asl #~D" (reg-asm-operand result)
               (reg-asm-operand n) shift)
        (let* ((res (reg-asm-operand result)))
          (emiti cg "mov ~A, ~A, asr #~D" res (reg-asm-operand n) (- shift))
          (emiti cg "and ~A, ~A, #~D" res res (ash -1 number-tag-bits)))))
  result)

(define-operator (ash n shift) ()
  (let* ((l1 (gen-label))
         (l2 (gen-label))
         (nreg (reg-asm-operand n))
         (shiftreg (reg-asm-operand shift))
         (resreg (reg-asm-operand result)))
    (emiti cg "movs ~A, ~A, asr #~D" shiftreg shiftreg number-tag-bits)
    (emiti cg "bmi ~A" l1)
    ;; n >= 0
    (emiti cg "cmp ~A, #31" shiftreg)
    (emiti cg "mov ~A, ~A, asl ~A" resreg nreg shiftreg)
    (emiti cg "movhi ~A, #0" resreg)
    (emit-jump cg l2)

    (emit-raw-label cg l1)
    ;; n < 0
    (emiti cg "rsb ~A, ~A, #0" shiftreg shiftreg)
    (emiti cg "cmp ~A, #31" shiftreg)
    (emiti cg "movhi ~A, #31" shiftreg)
    (emiti cg "mov ~A, ~A, asr ~A" resreg nreg shiftreg)
    (emiti cg "and ~A, ~A, #~D" resreg resreg (ash -1 number-tag-bits))

    (emit-raw-label cg l2))
  result)

;;; Conses

(define-tag-check pair? pair-tag pair-tag-bits)

(define-operator (cons a d) ()
  (emit-alloc cg pair-tag-bits (* 2 value-size) value-scale spare-regs)
  (emiti cg "str ~A, [~A]" (reg-asm-operand a) (reg-asm-operand %alloc))
  (emiti cg "str ~A, [~A, #4]" (reg-asm-operand d) (reg-asm-operand %alloc))
  (emiti cg "add ~A, ~A, #~D" (reg-asm-operand result)
         (reg-asm-operand %alloc) pair-tag)
  result)

(define-operator (car a) ()
  (emiti cg "ldr ~A, [~A, #~D]" (reg-asm-operand result) (reg-asm-operand a)
        (- pair-tag))
  result)

(define-operator (cdr a) ()
  (emiti cg "ldr ~A, [~A, #~D]" (reg-asm-operand result) (reg-asm-operand a)
        (- value-size pair-tag))
  result)

(define-operator (rplaca c a) ()
  (emiti cg "str ~A, [~A, #~D]" (reg-asm-operand a) (reg-asm-operand c)
        (- pair-tag))
  c)

(define-operator (rplacd c d) ()
  (emiti cg "str ~A, [~A, #~D]" (reg-asm-operand d) (reg-asm-operand c)
        (- value-size pair-tag))
  c)

;;; Symbols

(define-tag-check symbol? symbol-tag symbol-tag-bits)

(define-operator (raw-make-symbol str id) ()
  (emit-alloc cg symbol-tag-bits (* 2 value-size) value-scale spare-regs)
  (emiti cg "str ~A, [~A]" (reg-asm-operand str) (reg-asm-operand %alloc))
  (emiti cg "str ~A, [~A, #4]" (reg-asm-operand id) (reg-asm-operand %alloc))
  (emiti cg "add ~A, ~A, #~D" (reg-asm-operand result)
         (reg-asm-operand %alloc) symbol-tag)
  result)

(define-operator (symbol-name sym) ()
  (emiti cg "ldr ~A, [~A, #~D]" (reg-asm-operand result) (reg-asm-operand sym)
        (- symbol-tag))
  result)

(define-operator (symbol-id sym) ()
  (emiti cg "ldr ~A, [~A, #~D]" (reg-asm-operand result) (reg-asm-operand sym)
        (- value-size symbol-tag))
  result)

;;; Boxes

(define-operator (raw-make-box val) ()
  (emit-alloc cg box-tag-bits value-size value-scale spare-regs)
  (emiti cg "str ~A, [~A]" (reg-asm-operand val) (reg-asm-operand %alloc))
  (emiti cg "add ~A, ~A, #~D" (reg-asm-operand result)
         (reg-asm-operand %alloc) box-tag)
  result)

(define-operator (raw-box-set! box val) ()
  (emiti cg "str ~A, [~A, #~D]" (reg-asm-operand val) (reg-asm-operand box)
        (- box-tag))
  val)

(define-operator (raw-box-ref box) ()
  (emiti cg "ldr ~A, [~A, #~D]" (reg-asm-operand result) (reg-asm-operand box)
        (- box-tag))
  result)

;;; Strings and vectors

;;; We only support word and unsigned byte loads currently

(define-tag-check string? string-tag string-tag-bits)
(define-tag-check vector? vector-tag vector-tag-bits)

(define-operator (make-vec len (init fixed-reg %init-mem-val))
                 ((temp-fixed-regs %init-mem-count %init-mem-ptr))
  (let* ((tag (attr-ref attrs 'tag))
         (tag-bits (attr-ref attrs 'tag-bits))
         (scale (attr-ref attrs 'scale)))
    (emiti cg "mov ~A, #~D" (reg-asm-operand %init-mem-count) value-size)
    (emiti cg "add ~A, ~A, ~A~A" (reg-asm-operand %init-mem-count)
           (reg-asm-operand %init-mem-count) (reg-asm-operand len)
           (scale-number-expr scale))
    (emit-alloc cg tag-bits %init-mem-count scale
                (list* %init-mem-ptr spare-regs))
    (emiti cg "str ~A, [~A]" (reg-asm-operand len) (reg-asm-operand %alloc))

    ;; Call the helper routine to clear the vector
    (emiti cg "mov ~A, ~A, asr #~D" (reg-asm-operand %init-mem-count)
           (reg-asm-operand len) number-tag-bits)
    (emiti cg "bl ~A" (vector-ref init-mem-variants scale))

    (emiti cg "add ~A, ~A, #~D" (reg-asm-operand result)
          (reg-asm-operand %alloc) tag))
  result)

(define (vec-offset attrs index)
  (+ (ash index (attr-ref attrs 'scale))
     (- (attr-ref attrs 'header-size) (attr-ref attrs 'tag))))

;; We fully calculate constant offsets during codegen-simplify, so
;; that the operand constraints can accurately decide whether they fit
;; into the relevant immediate fields.
(define (identify-const-index-vec-op form attrs index)
  (when (eq? 'quote (car index))
    (let* ((indexval (second index)))
      (when (number? indexval)
        (rplaca form (compound-symbol (car form) "-const-index"))
        (overwrite-form index (list 'raw
                                    (acons 'value (vec-offset attrs indexval)
                                           ())))))))

(define-codegen-simplify (raw-vec-set! attrs vec index val)
  (codegen-simplify-recurse form)
  (identify-const-index-vec-op form attrs index))

(define-codegen-simplify ((raw-vec-ref vec-address) attrs vec index)
  (codegen-simplify-recurse form)
  (identify-const-index-vec-op form attrs index))

(define (emit-vec-const-index-op cg insn valreg ob vecreg index cb)
  (let* ((vec (reg-asm-operand vecreg))
         (val (reg-asm-operand valreg)))
    (if (number? index)
        (emiti cg "~A ~A, ~A~A, #~D~A" insn val ob vec index cb)
        (emiti cg "~A ~A, ~A~A, ~A~A" insn val ob vec (reg-asm-operand index)
               cb))))

(define-operator (raw-vec-set!-const-index vec (index reg-imm12) val) ()
  (emit-vec-const-index-op cg
                           (vector-ref str-variants (attr-ref attrs 'scale))
                           val "[" vec index "]")
  val)

(define-operator (raw-vec-ref-const-index vec (index reg-imm12)) ()
  (emit-vec-const-index-op cg
                           (vector-ref ldr-variants (attr-ref attrs 'scale))
                           result "[" vec index "]")
  result)

(define-operator (vec-address-const-index vec (index reg-imm8)) ()
  (emit-vec-const-index-op cg "add" result "" vec index "")
  result)

(define (emit-vec-op cg attrs insn val ob vecreg index cb)
  (let* ((header-size (attr-ref attrs 'header-size))
         (tag (attr-ref attrs 'tag))
         (vec (reg-asm-operand vecreg)))
    (unless (= header-size tag)
      (emiti cg "add ~A, ~A, #~D" vec vec (- header-size tag)))
    (emiti cg "~A ~A, ~A~A, ~A~A~A" insn (reg-asm-operand val) ob
           vec (reg-asm-operand index)
           (shift-expr (- number-tag-bits (attr-ref attrs 'scale)))
           cb)))

(define-operator (raw-vec-set! vec index val) ()
  (emit-vec-op cg attrs (vector-ref str-variants (attr-ref attrs 'scale))
               val "[" vec index "]")
  val)

(define-operator (raw-vec-ref vec index) ()
  (emit-vec-op cg attrs (vector-ref ldr-variants (attr-ref attrs 'scale))
               result "[" vec index "]")
  result)

(define-operator (vec-address vec index) ()
  (emit-vec-op cg attrs "add" result "" vec index "")
  result)

(define-operator (vec-length vec) ()
  (emiti cg "ldr ~A, [~A, #~D]" (reg-asm-operand result) (reg-asm-operand vec)
        (- (attr-ref attrs 'tag)))
  result)

(define-trashy-codegen (copy-mem attrs src-addr dest-addr len)
  (trashy-codegen-into-regs cg (list dest-addr src-addr len) c-call-arg-regs)
  (let* ((len (reg-asm-operand (third c-call-arg-regs))))
    (emiti cg "mov ~A, ~A~A" len len
           (scale-number-expr (attr-ref attrs 'scale))))
  (emit-c-call cg "memmove")
  unspecified-representation)

;;; Misc runtime support

(define-operator (fixnum->raw (val reg-imm)) ()
  (if (immediate? val)
      (ash val (- number-tag-bits))
      (begin
        (emiti cg "mov ~A, ~A, asr #~D" (reg-asm-operand result)
               (reg-asm-operand val) number-tag-bits)
        result)))

(define-operator (raw->fixnum (val reg-imm)) ()
  (if (immediate? val)
      (fixnum-representation val)
      (begin
        (emiti cg "mov ~A, ~A, asl #~D" (reg-asm-operand result)
               (reg-asm-operand val) number-tag-bits)
        result)))

(define-operator (raw-label) ()
  (emiti cg "ldr ~A, =~A" (reg-asm-operand result) (attr-ref attrs 'name))
  result)

(define-operator (raw-global-set! val) ((temp-regs temp))
  (let* ((name (attr-ref attrs 'name))
         (rglob (assoc name register-globals)))
    (if rglob
        (emiti cg "mov ~A, ~A"
               (reg-asm-operand (cdr rglob)) (reg-asm-operand val))
        (access-global cg "str" val name temp)))
  val)

(define-operator (raw-global-ref) ((temp-regs temp))
  (let* ((name (attr-ref attrs 'name))
         (rglob (assoc name register-globals)))
    (if rglob
        (emiti cg "mov ~A, ~A"
                (reg-asm-operand result) (reg-asm-operand (cdr rglob)))
        (access-global cg "ldr" result name temp)))
  result)

(define-operator (raw-ref addr) ()
  (emiti cg "~A ~A, [~A]" (vector-ref ldr-variants (attr-ref attrs 'scale))
         (reg-asm-operand result) (reg-asm-operand addr))
  result)

(define-operator (raw-set! addr val) ()
  (emiti cg "~A ~A, [~A]" (vector-ref str-variants (attr-ref attrs 'scale))
         (reg-asm-operand val) (reg-asm-operand addr))
  val)

(define (emit-c-call cg label)
  ;; EABI says that the stack should be aligned to 8 bytes when
  ;; calling a public interface
  (let* ((saved-sp (reg-asm-operand (first c-callee-saved-regs))))
    (emiti cg "mov ~A, sp" saved-sp)
    (emiti cg "and sp, sp, #-8")
    (emiti cg "bl ~A" label)
    (emiti cg "mov sp, ~A" saved-sp)))

(define-trashy-codegen (c-call attrs . args)
  (trashy-codegen-into-regs cg args c-call-arg-regs)
  (emit-c-call cg (attr-ref attrs 'c-function-name))
  %r0)

;; the gc uses the raw-alloc operation

(define-operator (raw-alloc size) ()
  (emit-alloc cg (compiler-constant-value (attr-ref attrs 'tag-bits))
              (string-concat (reg-asm-operand size)
                             (scale-number-expr value-scale))
              value-scale spare-regs)
  %alloc)

;;; Heap allocation

(define (register-bitset regs)
  (reduce (register-bit (car regs)) (cdr regs)
          (lambda (bits reg) (logior bits (register-bit reg)))))

(define (emit-alloc cg tag-bits size scale spare-regs)
  (let* ((again-label (gen-label))
         (exhausted-label (gen-label))
         (alloc (reg-asm-operand %alloc))
         (threshold (reg-asm-operand %threshold)))
    (flush-labels-and-jumps cg)
    (emit-raw-label cg again-label)
    (emiti cg "sub ~A, ~A, ~A" alloc alloc (asm-operand size))
    (unless (= tag-bits scale)
      (emiti cg "and ~A, ~A, #~D" alloc alloc (- (ash 1 tag-bits))))
    (emiti cg "cmp ~A, ~A" alloc threshold)
    (emiti cg "blo ~A" exhausted-label)

    (codegen-push-out-of-line cg
      (lambda ()
        (emit-raw-label cg exhausted-label)
        (emiti cg "ldr ~A,=~D" (reg-asm-operand %closure)
               (register-bitset spare-regs))
        (emiti cg "bl heap_exhausted")
        (emit-restore-%closure cg)
        (emiti cg "b ~A" again-label)
        (emit-ltorg cg)))))

(define gc-label (make-label-for 'gc direct-function-label-prefix))

(define (codegen-helpers cg)
  (codegen-heap-exhausted cg)
  (codegen-init-mem cg 0)
  (codegen-init-mem cg 2))

(define (codegen-heap-exhausted cg)
  (labels ((for-live-registers (regs insn-template)
             (dolist (reg regs)
               (emiti cg "tst ~A, #~D" (reg-asm-operand %closure)
                     (register-bit reg))
               (emiti cg insn-template "eq" (reg-asm-operand reg)))))
    (emit cg ".text")
    (emit cg ".globl heap_exhausted")
    (emit cg "heap_exhausted:")

    (emiti cg "str lr, [sp, #-4]!")

    ;; Push live registers onto the stack, guided by the bitset in
    ;; %closure.  This preserves their values, and also means that
    ;; they get treated as part of the root set by the GC.
    (for-live-registers general-registers "str~A ~A, [sp, #-4]!")

    (let* ((reg (reg-asm-operand %closure)))
      ;; We need to save the live reg bitset from %closure, in order to
      ;; restore the live registers after the GC.  But if we put it on
      ;; the stack it it's original form, the GC will see it and try to
      ;; interpret it as an object reference.  So we disguise it as a
      ;; fixnum first.
      (emiti cg "mov ~A, ~A, asl #~D" reg reg number-tag-bits)
      (emiti cg "str ~A, [sp, #-4]!" reg)
      (emiti cg "bl ~A" gc-label)
      (emiti cg "ldr ~A, [sp], #4" reg)
      (emiti cg "mov ~A, ~A, asr #~D" reg reg number-tag-bits))

    ;; Restore live registers
    (for-live-registers (reverse general-registers) "ldr~A ~A, [sp], #4")

    (emiti cg "ldr lr, [sp], #4")
    (emiti cg "mov pc, lr")))

;;; Raw ops for the GC

(define-simple-number-operator raw-+ "add")
(define-simple-number-operator raw-- "sub")
(define-simple-number-operator raw-logand "and")
