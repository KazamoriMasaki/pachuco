;;; x86_64-specific code generation

;;; Bitness-dependent assembler bits

(define (emit-literal cg lit)
  (emit cg ".quad ~A" lit))

(define (emit-movzx cg src dest src-scale . dest-scale)
  (set! dest-scale (if (null? dest-scale) value-scale (car dest-scale)))
  (if (= dest-scale 3)
      (if (= src-scale 3)
          (emit cg "movq ~A, ~A" (value-sized src) (value-sized dest))
          (emit-movzx-32 cg src dest src-scale 2))
      (emit-movzx-32 cg src dest src-scale dest-scale)))

(define (emit-extend-sign-bit cg oper)
  (emit-sar cg 63 oper))

;;; rip-relative addressing is shorter on x86-64, but is not the
;;; default in the assembly syntax:

(define (indirect-operand addr)
  (unless (string? addr)
    (error "indirect operand ~S, which is surprising" addr))
  (format~ false "~A(%rip)" addr))

;;; C calls

(define-trashy-codegen (c-call attrs . args)
  (trashy-codegen-into-regs cg args c-call-arg-regs)

  (emit cg "cld")
  (emit-set-ac-flag cg false)

  ;; C ABI requires us to align stack to 16 byte bundary
  (emit-mov cg %sp %b)
  (emit-and cg -16 %sp)
  (emit cg "call ~A" (attr-ref attrs 'c-function-name))
  (emit-mov cg %b %sp)

  (emit-set-ac-flag cg true)
  (unless (member? %closure c-callee-saved-regs) (emit-restore-%closure cg))
  %a)
