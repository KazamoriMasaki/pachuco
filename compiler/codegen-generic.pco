;;; Code generation bits that aren't dependent on the target, the
;;; stack regime, the code generation strategy, or anything else

(define (codegen-push-out-of-line cg f)
  ;; When we push an out-of-line function, we need to save the
  ;; relevant coedegen state.  Currently this amounts to the
  ;; frame-base
  (codegen-set-out-of-line! cg (cons (cons f (codegen-frame-base cg))
                                     (codegen-out-of-line cg))))

(define (codegen-do-out-of-line cg)
  (let* ((ool (codegen-out-of-line cg)))
    (unless (null? ool)
      (codegen-set-out-of-line! cg (cdr ool))
      (codegen-set-frame-base! cg (cdar ool))
      (funcall (caar ool))
      (codegen-do-out-of-line cg))))

(define (codegen-lambda-todo cg form)
  (codegen-set-todo! cg (cons form (codegen-todo cg))))

(define (codegen-do-todos cg)
  (let* ((todo (codegen-todo cg)))
    (unless (null? todo)
      (codegen-set-todo! cg (cdr todo))
      (codegen-function cg (car todo))
      (codegen-do-todos cg))))

(define (fixnum-representation n) (ash n number-tag-bits))
(define (low-bits-mask bits) (1- (ash 1 bits)))

(define (emit-comment-form cg form)
  (unless (eq? 'begin (car form))
    (emit-comment cg "~S" (comment-form form))))

(define (register-bitset regs)
  (reduce 0 regs
          (lambda (bits reg) (logior bits (register-bit reg)))))

;; Assembly utility functions

(define (emit-data cg label scale)
  (emit cg ".section .rodata")
  (emit-align cg scale)
  (emit cg "~A:" label))

;;; Generate the prologue to the assembly output
(define (codegen-program-start cg program)
  (labels ((emit-label (label)
             (emit cg ".globl ~A" label)
             (emit cg "~A:" label)))
    (emit cg ".section .bss")
    (emit-align cg value-scale)
    (emit-label "top_level_start")

    (dolist (varrec (second program))
      (when (eq? 'arity-mismatch (varrec-name varrec))
        (codegen-set-arity-mismatch-varrec! cg varrec))

      (unless (varrec-const? varrec)
        (let* ((label (make-label-for (varrec-name varrec)
                                      variable-label-prefix)))
          (varrec-set-index! varrec label)
          (emit-comment cg "top-level ~S" (varrec-name varrec))
          (emit-label label)
          (emit-literal cg unspecified-representation))))

    (emit-label "top_level_end"))

  (codegen-set-have-closure! cg false))

;;; Finish off the assembly output
(define (codegen-program-end cg)
  (codegen-do-todos cg)
  (codegen-helpers cg)
  (codegen-symbols cg)

  ;; This indicates to the linker that we support a non-executable stack
  (emit cg ".section .note.GNU-stack,\"\",%progbits"))

(define (codegen-function cg form)
  (let* ((attrs (second form))
         (closure (attr-ref attrs 'closure))
         (indirect-label (attr-ref attrs 'indirect-label)))
    (labels ((assign-varrec-indices (varrecs)
               ;; assign slot indices to varrecs
               (let* ((index 0))
                 (dolist (varrec varrecs)
                   (varrec-set-index! varrec index)
                   (set! index (1+ index))))))
      (assign-varrec-indices closure)
      (assign-varrec-indices (attr-ref attrs 'params)))

    (emit cg ".text")
    (emit-align cg value-scale)
    (emit-literal cg (fixnum-representation (1+ (length closure))))
    (emit-function-label cg indirect-label)

    (let* ((self-varrec (attr-ref attrs 'self)))
      (when self-varrec
        (emit-comment cg "function ~S" (varrec-name self-varrec))))

    (unless (attr-ref attrs 'vararg)
      (let* ((nparams (length (attr-ref attrs 'params)))
             (bad-nargs-label (gen-label)))
        (emit-check-nargs cg nparams bad-nargs-label)
        (codegen-push-out-of-line cg
          (lambda ()
            (emit-smart-label cg bad-nargs-label)
            (emit-function-prologue cg)
            (let* ((expr (quasiquote
               (return ((nparams . (unquote nparams)))
                       (call ()
                             (ref (unquote (codegen-arity-mismatch-varrec cg)))
                             (quote (unquote nparams))
                             (arg-count ()))))))
              (codegen-simplify expr)
              (trashy-codegen-discarding expr cg false))))
        (emit-function-label cg (attr-ref attrs 'direct-label))))

    (emit-function-prologue cg)
    (codegen-set-have-closure! cg (if (null? closure)
                                      false
                                      (begin
                                        (emit-frame-push cg %closure)
                                        true)))
    (codegen-body cg (attr-ref attrs 'body) false)
    (codegen-do-out-of-line cg)
    (emit cg ".size ~A, .-~A" indirect-label indirect-label)))

;;; Generate code for the body of a function or main program body
(define (codegen-body cg body out-frame-base)
  (codegen-simplify body)
  (emit-comment-form cg body)
  (trashy-codegen-discarding body cg out-frame-base))

;;; "Smart" branching, jumping, and labels.
;;;
;;; These do some simple flow control optimizations.  For example,
;;;
;;;     (if (and A B) C D)
;;;
;;; which after macro-expansion is
;;;
;;;     (if (if A B false) C D)
;;;
;;; might naively yield
;;;
;;;     <code to yield A as boolean in CC1>
;;;     jnCC1 L1b ; branch to code for A false
;;;     jmp L1a   ; jump to code for A true
;;;
;;;     L1a:      ; A true
;;;     <code to yield B as boolean in CC2>
;;;     jnCC2 L2b ; branch to code for D
;;;     jmp L2a   ; branch to code for C
;;;     jmp L1c   ; unreachable branch to code after (if A B false)
;;;
;;;     L1b:      ; A false
;;;     jmp L2b   ; branch to code for D
;;;
;;;     L1c:      ; code following (if A B false) would go here...
;;;
;;;     L2a:
;;;     <code for C>
;;;     jmp L2c
;;;
;;;     L2b:
;;;     <code for D>
;;;
;;;     L2c:
;;;
;;; instead yields
;;;
;;;     <code to yield A as boolean in CC1>
;;;     jnCC1 L1b ; branch to code for A false
;;;
;;;     L1a:      ; A true
;;;     <code to yield B as boolean in CC2>
;;;     jnCC2 L2b ; branch to code for D
;;;
;;;     L2a:
;;;     <code for C>
;;;     jmp L2c
;;;
;;;     L1b:      ; A false
;;;     L2b:
;;;     <code for D>
;;;
;;;     L2c:
;;;
;;; The basic order of code is unchanged, but redundant jumps have
;;; been eliminated, and labels have been moved accordingly.  The key
;;; thing to notice here is that labels have all been moved later in
;;; the instruction stream.  This works because the compiler always
;;; generates jumps/branches forwards, never backwards.
;;;
;;; Thus we simply have to maintain a small amonut of state as we
;;; output instructions to tell us what special treatment is required
;;; for jumps, branches and labels.  This consists of three slots in
;;; the codegen object:
;;;
;;; - deferred-jump: A function representing the pending jump or
;;; branch, if any.  This function is called to emit the jump in
;;; flush-labels-and-jumps.  It's false when not optimising flow.
;;;
;;; - here-labels: The list of labels attached to the current point in
;;; the instruction stream.
;;;
;;; - redirect-labels: an alist from labels to the labels they
;;; redirect to.  We never change the label of a jump/branch; instead,
;;; when we emit a label, we also emit all the labels that redirect to
;;; it.

(define (emit-smart-jump cg label)
  (if (codegen-deferred-jump cg)
      (begin
        ;; there is no direct way to reach this jump, so all the here
        ;; labels now redirect to the jumped-to label
        (codegen-set-redirect-labels! cg
          (nconc (nmapfor (l (codegen-here-labels cg)) (cons l label))
                 (codegen-redirect-labels cg)))
        (codegen-set-here-labels! cg ()))
      (codegen-set-deferred-jump! cg
        (lambda ()
          ;; emit a jump, unless we are jumping to a here label
          (unless (member? label (codegen-here-labels cg))
            (emit-jump cg label))))))

(define (emit-smart-branch cg cc out-frame-base tlabel flabel)
  (emit-reset-frame-base cg out-frame-base)
  (flush-labels-and-jumps cg)
  (codegen-set-deferred-jump! cg
    (lambda ()
      (let* ((here-labels (codegen-here-labels cg)))
        (if (member? tlabel here-labels)
            (unless (member? flabel here-labels)
              (emit-branch cg (negate-cc cc) flabel))
            (begin
             (emit-branch cg cc tlabel)
             (unless (member? flabel here-labels)
               (emit-jump cg flabel))))))))

(define (emit-raw-label cg label)
  (emit-without-flushing "~A:" label))

(define (emit-smart-label cg label)
  (let* ((here-labels (cons label (nconc (codegen-here-labels cg)
                                         (take-merged-labels cg label)))))
    (if (codegen-deferred-jump cg)
        (codegen-set-here-labels! cg here-labels)
        (dolist (ml here-labels) (emit-raw-label cg ml)))))

(define (take-merged-labels cg label)
  ;; extract the labels which lead to label
  (let* ((res ()))
    (codegen-set-redirect-labels! cg
      (nfilterfor (redirect (codegen-redirect-labels cg))
        (if (eq? label (cdr redirect))
            (begin
              (push (car redirect) res)
              false)
            true)))
    res))

(define (flush-labels-and-jumps cg)
  (let* ((jump-func (codegen-deferred-jump cg)))
    (when jump-func
      (codegen-set-deferred-jump! cg false)
      (funcall jump-func)
      (let* ((here-labels (codegen-here-labels cg)))
        (if (null? here-labels)
            (emit-comment cg "unreachable")
            (begin
              (codegen-set-here-labels! cg ())
              (dolist (l here-labels)
                (emit-without-flushing "~A:" l))))))))

(define (codegen-function-tail cg out-frame-base)
  ;; signals unreachable code after the tail form of a function,
  ;; e.g. after a return instruction, tail call, etc.  A tail form is
  ;; quite likely to have messed with the stack pointer, but we can
  ;; pretend for the sake of the context that it set it to the
  ;; expected value.
  (codegen-set-frame-base! cg out-frame-base)
  (unless (codegen-deferred-jump cg)
    (codegen-set-deferred-jump! cg (lambda ()))))

;;; Literals

(define-operator (raw) () attrs)

(define (quote-false? form)
  (and (eq? 'quote (car form)) (eq? (second form) #f)))

(define-operator (quote) ()
  (let* ((val (codegen-quoted attrs cg)))
    ;;; If the quoted form resulted in a label, that means it emitted
    ;;; code, and we need to switch back to the code section
    (unless (number? val) (emit cg ".text"))
    val))

(defconstant positive-number-mask (1- (ash 1 (- value-bits number-tag-bits))))
(defconstant negative-number-mask (ash -1 (- value-bits number-tag-bits 1)))

;;; Normalize a number to fit in value-bits.  It's useful that this
;;; preserves the sign of the number, so that -1 remains -1 in the
;;; generated assembly.
(define (normalize-number n)
  (if (>= n 0)
      (logand n positive-number-mask)
      (logior n negative-number-mask)))

(define (codegen-quoted quoted cg)
  (cond ((pair? quoted) (codegen-quoted-pair quoted cg))
        ((number? quoted) (fixnum-representation (normalize-number quoted)))
        ((character? quoted) (fixnum-representation (character-code quoted)))
        ((string? quoted) (codegen-quoted-string quoted cg))
        (true (let* ((c (assoc quoted simple-representations)))
             (cond (c (cdr c))
                   ((symbol? quoted) (codegen-quoted-symbol quoted cg))
                   (true (error "unrecognised quoted form ~S" quoted)))))))

(define (codegen-quoted-pair quoted cg)
  (let* ((label (gen-label))
         (a (codegen-quoted (car quoted) cg))
         (d (codegen-quoted (cdr quoted) cg)))
    (emit-data cg label pair-tag-bits)
    (emit-literal cg a)
    (emit-literal cg d)
    (format "~A+~D" label pair-tag)))

(define emitted-strings (make-hashtable (function string-hash)
                                        (function string-equal?)))

(define (codegen-quoted-string str cg)
  (or (hashtable-ref emitted-strings str)
      (let* ((label (gen-label)))
        (emit-data cg label string-tag-bits)
        (emit-literal cg (fixnum-representation (string-length str)))
        (emit cg ".ascii \"~A\"" (escape-string-literal str))
        (hashtable-set! emitted-strings  str
                        (format "~A+~D" label string-tag)))))

(define (escape-string-literal str)
  (string-replace (string-replace (string-replace str "\\" "\\\\")
                                  "\"" "\\\"") "
" "\\n"))

(define emitted-symbols (make-symboltable))
(define emitted-symbol-counter 0)

(define (codegen-quoted-symbol sym cg)
  (let* ((lit (symboltable-ref emitted-symbols sym)))
    (or lit
        (let* ((label (make-label-for sym symbol-label-prefix))
               (name (codegen-quoted-string (subject-language-symbol-name sym)
                                            cg)))
          (emit-data cg label symbol-tag-bits)
          (emit cg ".globl ~A" label)
          (emit-literal cg name)
          (emit-literal cg (fixnum-representation
                    (set! emitted-symbol-counter (1+ emitted-symbol-counter))))
          (set! lit (format "~A+~D" label symbol-tag))
          (symboltable-set! emitted-symbols sym lit)
          lit))))

(define (codegen-symbols cg)
  (emit-data cg "symbols_start" value-scale)
  (emit cg ".globl symbols_start")

  (let* ((sym-lits ()))
    (for-hashtable (sym lit emitted-symbols)
      (set! sym-lits (acons sym lit sym-lits)))

    (dolist (sym-lit (sort sym-lits (lambda (a b)
                                      (string< (symbol-name (car a))
                                               (symbol-name (car b))))))
      (emit-literal cg (cdr sym-lit))))

  (emit cg "symbols_end:")
  (emit cg ".global symbols_end"))

;;; Stack handling

(define (emit-frame-push cg reg)
  (emit-push cg reg)
  (codegen-set-frame-base! cg (1+ (codegen-frame-base cg))))

(define (emit-frame-pop cg reg)
  (emit-pop cg reg)
  (codegen-set-frame-base! cg (1- (codegen-frame-base cg))))

(define (emit-reset-frame-base cg out-frame-base)
  (when out-frame-base
    (let* ((in-frame-base (codegen-frame-base cg)))
      (unless (= in-frame-base out-frame-base)
        (emit-offset-sp cg (- in-frame-base out-frame-base))
        (codegen-set-frame-base! cg out-frame-base)))))

;;; Variables

(define-codegen-simplify (define varrec val)
  (codegen-simplify val)
  (if (varrec-const? varrec)
      ;; don't need the define for a constant varrec
      (overwrite-form form val)
      (begin
        ;; make the varrec into a normal attribute, in order to use
        ;; define-operator
        (rplaca (cdr form) (acons 'varrec varrec ()))
        ;; convert define for top-level variables to set!
        (when (varrec-top-level? varrec)
          (rplaca form 'set!)
          (codegen-simplify-set! form varrec)))))

(define-codegen-simplify (set! varrec val)
  (codegen-simplify val)
  ;; make the varrec into a normal attribute, in order to use
  ;; define-operator
  (rplaca (cdr form) (acons 'varrec varrec ()))
  (codegen-simplify-set! form varrec))

(define-codegen-simplify (ref varrec)
  ;; make the varrec into a normal attribute, in order to use
  ;; define-operator
  (rplaca (cdr form) (acons 'varrec varrec ())))

;;; Simplifications of arithmetic operators

(define (make-bin-op-expr op expr a)
  (if expr (list op () expr a) a))

(define (numberish-value expr)
  (and (eq? 'quote (car expr))
       (let* ((n (second expr)))
         (cond ((number? n) n)
               ((character? n) (character-code n))
               (true (error "expected number, got ~A" n))))))

;; scan the arguments, separating them into constants and
;; non-constants.  Fold the constants, and construct an expression for
;; the non-constants from simple two-argument operations,
(define (simplify-binary-op args op f expr const)
  (if (not (null? args))
      (let* ((a (car args))
             (aval (numberish-value a)))
        (if aval
            (simplify-binary-op (cdr args) op f expr (funcall f const aval))
            (simplify-binary-op (cdr args) op f
                                (make-bin-op-expr op expr a) const)))
      (cons expr const)))

(define (simplify-comm-binary-op form args f identity make-const-expr)
  (codegen-simplify-recurse form)
  (let* ((expr-const (simplify-binary-op args (car form) f false identity))
         (expr (car expr-const))
         (const (cdr expr-const)))
    (overwrite-form form
      (or (if (= const identity)
              expr
              ;; always put the quoted arg in the second
              ;; position, for better code generation
              (funcall make-const-expr expr const))
          (list 'quote identity)))))

(define-codegen-simplify (+ attrs . args)
  (simplify-comm-binary-op form args (function +) 0
    (lambda (expr const) (make-bin-op-expr '+ expr (list 'quote const)))))

;; This only handles positive numbers with a single bit set
(define (log2 n)
  (+ (if (= 0 (logand n #x00000000ffffffff)) 32 0)
     (if (= 0 (logand n #x0000ffff0000ffff)) 16 0)
     (if (= 0 (logand n #x00ff00ff00ff00ff)) 8 0)
     (if (= 0 (logand n #x0f0f0f0f0f0f0f0f)) 4 0)
     (if (= 0 (logand n #x3333333333333333)) 2 0)
     (if (= 0 (logand n #x5555555555555555)) 1 0)))

(define-codegen-simplify (* attrs . args)
  (simplify-comm-binary-op form args (function *) 1
    (lambda (expr const)
      (cond ((and expr (> const 0) (= 0 (logand const (1- const))))
             (list 'ash-imm (acons 'shift (log2 const) ()) expr))
            ((not expr)
             (list 'quote const))
            (true
             (list 'raw-* () expr (list 'raw const)))))))

(define-codegen-simplify (- attrs a . args)
  (codegen-simplify-recurse form)
  (if (null? args)
      (if (eq? 'quote (car a))
          ;; (- (quote x)) => (quote -x)
          (overwrite-form form (list 'quote (- (second a))))
          ;; (- x) => (negate x)
          (rplaca form 'negate))
      (let* ((aval (numberish-value a)))
        (if aval
            ;; If the left-hand argument is a constant, we can't
            ;; constant fold it away.  Instead, fold any other
            ;; constants into it.
            (let* ((expr-const
                     (simplify-binary-op args '- (function -) a aval)))
              (rplaca (cdr a) (cdr expr-const))
              (overwrite-form form (car expr-const)))
            (let* ((expr-const (simplify-binary-op args '- (function -) a 0))
                   (expr (car expr-const))
                   (const (cdr expr-const)))
              (overwrite-form form
                (if (= const 0)
                    expr
                    (make-bin-op-expr '+ expr (list 'quote const)))))))))

(define-codegen-simplify ((eq? = /=) attrs a b)
  (codegen-simplify-recurse form)
  ;; always move a quoted arg to the second position, for better code
  ;; generation
  (when (eq? 'quote (car a))
    (overwrite-form form (list (car form) attrs b a))))

;; This reorders inequalities for better code generation.  But it turns
;; out we don't have any that need reordering.
;;
;;(define-codegen-simplify ((> < >= <=) attrs a b)
;;  (codegen-simplify-recurse form)
;;  ;; always move a quoted arg to the second position, for better code
;;  ;; generation
;;  (when (eq? 'quote (car a))
;;    (overwrite-form form (list (car (assoc (car form)
;;                                      '((> . <) (< . >) (<= . >=) (>= . <=))))
;;                               attrs b a))))

;; Distinguish the constant-bit-count for of ash from the
;; variable-bit-count form, because they lead to significantly
;; different code.
(define-codegen-simplify (ash attrs n shift)
  (codegen-simplify-recurse form)
  (when (eq? 'quote (car shift))
    (let* ((shiftval (second shift)))
      (unless (number? shiftval) (error "ash with non-number"))

      (overwrite-form form
        (cond ((eq? 'quote (car n))
               (let* ((nval (second n)))
                 (unless (number? nval) (error "ash with non-number"))
                 (list 'quote (ash nval shiftval))))
              ((= shiftval 0)
               n)
              ((<= shiftval (- value-bits))
               ;; Large right shifts result in 0 or -1, depending on
               ;; the sign of the operand.  So we turn them all into
               ;; a {31,63}-bit right shift.
               (list 'ash-imm (acons 'shift (- 1 value-bits) attrs) n))
              ((< shiftval value-bits)
               (list 'ash-imm (acons 'shift shiftval attrs) n))
              (true
               (quasiquote (begin () (unquote n) (quote 0)))))))))

;;; Function calls

(define (func-lambda func)
  (cond ((eq? 'ref (first func))
         (varrec-lambda (varrec-origin (form-attr func 'varrec))))
        ((member? (first func) '(lambda static-lambda))
         func)
        (true
         false)))

(define (check-call-nargs l nargs)
  (let* ((expected (length (form-attr l 'params)))
         (at-least ""))
    (when (if (form-attr l 'vararg)
              (begin
                (set! at-least "at least ")
                (< nargs expected))
              (/= nargs expected))
      (let* ((varrec (form-attr-defaulting l 'self false)))
        (error "wrong number of arguments in call to ~A (expected ~A~D, got ~D)"
               (if varrec (varrec-name varrec) "anonymous function")
               at-least expected nargs)))))

(define-operator (set-closure! closure val) ()
  (emit-store-into-closure cg closure (attr-ref attrs 'index) val)
  val)

;; Do all the compile-time magic needed to make statically-known
;; function calls fast:
;;
;; - Checking the number of arguments at compile time.
;;
;; - Storing the number of arguments in %nargs
;;
;; - Working out which label to branch to.
;;
;; - Decide whether the closure needs computing
(define (simplify-call form func pre-func-cons args)
  (codegen-simplify-recurse form)
  (let* ((nargs (length args))
         (needs-nargs true)
         (needs-closure true)
         (label false)
         (l (func-lambda func)))
    (when l
      (check-call-nargs l nargs)
      (unless (form-attr l 'vararg) (set! needs-nargs false))
      (set! label (form-attr l 'direct-label))

      (when (cond ((and (eq? 'ref (first func))
                        (eq? 'self (varrec-mode (form-attr func 'varrec))))
                   ;; self calls don't need to evaluate func, they
                   ;; already have it in %closure
                   true)

                  ((eq? 'static-lambda (first l))
                   ;; static-lambda calls don't need to evaluate func.
                   ;; Exception, if it's a direct static-lambda form,
                   ;; rather than a ref, we still need to ensure that
                   ;; code gets generated for it
                   (when (eq? 'static-lambda (first func))
                     (let* ((old-form (cons (car form) (cdr form))))
                       (overwrite-form form (list 'begin () func old-form))
                       (set! form old-form)))
                   true)

                  (true
                   false))
        ;; Remove func argument
        (rplacd pre-func-cons args)
        (set! needs-closure false)))

    (rplaca (cdr form)
            (list* (cons 'nargs nargs)
                   (cons 'needs-nargs needs-nargs)
                   (cons 'needs-closure needs-closure)
                   (cons 'label label)
                   (second form)))))

(define-codegen-simplify ((call tail-call) attrs func . args)
  (simplify-call form func (cdr form) args))

(define-codegen-simplify (varargs-tail-call attrs arg-count func . args)
  (simplify-call form func (cddr form) args))

(define-codegen-simplify (raw-jump-with-arg-space attrs
                                before-arg-count after-arg-count bodyfunc)
  (simplify-call form bodyfunc (cdddr form) ()))

(define (codegen-call-args cg attrs args)
  (labels ((for-args (args)
             (unless (null? args)
               (for-args (cdr args))
               (emit-frame-spill cg (trashy-codegen (car args) cg false)
                                 (first general-registers)))))
    (if (attr-ref attrs 'needs-closure)
        (begin
          (for-args (cdr args))
          (trashy-codegen-into-reg (car args) cg false %closure))
        (for-args args))))

(define (emit-call-or-jump cg attrs call-or-jump)
  (when (attr-ref attrs 'needs-nargs)
    (emit-mov cg (fixnum-representation (attr-ref attrs 'nargs)) %nargs))
  (let* ((label (attr-ref attrs 'label)))
    (if label
        (emit-direct-call-or-jump cg call-or-jump label)
        (emit-indirect-call-or-jump cg call-or-jump))))

(define (static-lambda-closure-label l)
  (let* ((cl (form-attr-defaulting l 'closure-label false)))
    (if (string? cl)
        cl
        (begin
          (set! cl (make-label-for cl closure-label-prefix))
          (form-attr-set! l 'closure-label cl)))))

(define-operator (static-lambda) ()
  (codegen-lambda-todo cg form)
  (let* ((label (static-lambda-closure-label form)))
    (emit-data cg label closure-tag-bits)
    (emit-literal cg (attr-ref attrs 'indirect-label))
    (emit cg ".text")
    (format "~A+~D" label closure-tag)))

(define (varrec-const? varrec)
  (let* ((l (varrec-lambda varrec)))
    (and l (eq? 'static-lambda (first l)))))

(define (varrec-const-operand varrec)
  (let* ((l (varrec-lambda varrec)))
    (and l
         (eq? 'static-lambda (first l))
         (format "~A+~D" (static-lambda-closure-label l) closure-tag))))

(define-codegen-simplify (c-call c-function-name . args)
  (rplaca (cdr form) (list (cons 'c-function-name c-function-name)))
  (codegen-simplify-recurse form))

(define-operator (arg-count) () %nargs)

;;; Type check operators

(define-tag-check function? closure-tag closure-tag-bits)
(define-tag-check pair? pair-tag pair-tag-bits)
(define-tag-check symbol? symbol-tag symbol-tag-bits)
(define-tag-check number? number-tag number-tag-bits)
(define-tag-check string? string-tag string-tag-bits)
(define-tag-check vector? vector-tag vector-tag-bits)

;;; Misc runtime support

(define-codegen-simplify ((raw-label raw-global-ref) name)
  (rplaca (cdr form) (list (cons 'name name))))

(define-codegen-simplify (raw-global-set! name val)
  (codegen-simplify val)
  (rplaca (cdr form) (list (cons 'name name))))

(define-codegen-simplify (raw-alloc tag-bits-ccsym size)
  (codegen-simplify size)
  (rplaca (cdr form) (list (cons 'tag-bits tag-bits-ccsym))))

;; raw-jump-with-arg-space and raw-apply-jump should always appear in
;; tail positions
(define-propagate ((raw-jump-with-arg-space raw-apply-jump) . rest))

;;; String/vector support

(define (genericize-vec-op form name attrs)
  ;; convert a vector-type-specific operator into a generic vec operator
  (rplaca form name)
  (rplaca (cdr form) attrs)
  (codegen-simplify form))

(define (make-copy-mem-form src src-index dest dest-index len attrs)
  (quasiquote
    (copy-mem (unquote attrs)
              (vec-address (unquote attrs) (unquote src) (unquote src-index))
              (vec-address (unquote attrs) (unquote dest) (unquote dest-index))
              (unquote len))))

(defmacro (define-vector-type name tag tag-bits scale protect
                              from-vec-rep to-vec-rep)
  (let* ((type-attrs (compound-symbol name "-type-attrs")))
    ;; define how to convert from the operators on a specific vector
    ;; type into generic vec operators
    (quasiquote (definitions
      (define (unquote type-attrs)
        (list (cons 'tag (unquote tag))
              (cons 'tag-bits (unquote tag-bits))
              (cons 'scale (unquote scale))
              (cons 'header-size value-size)
              (cons 'protect (unquote protect))))

      (define-codegen-simplify ((unquote (compound-symbol "make-" name))
                                attrs len init)
        (rplaca (cdddr form) ((unquote to-vec-rep) init))
        (genericize-vec-op form 'make-vec (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-length"))
                                attrs vec)
        (genericize-vec-op form 'vec-length (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-address"))
                                attrs vec index)
        (genericize-vec-op form 'vec-address (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-ref"))
                                attrs vec index)
        (genericize-vec-op form 'raw-vec-ref (unquote type-attrs))
        (overwrite-form form ((unquote from-vec-rep) (copy-list form))))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-set!"))
                                attrs vec index val)
        (rplaca (cddddr form) ((unquote to-vec-rep) val))
        (genericize-vec-op form 'raw-vec-set! (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-copy"))
                                attrs src src-index dest dest-index len)
        (overwrite-form form (make-copy-mem-form src src-index dest dest-index
                                                 len (unquote type-attrs)))
        (codegen-simplify-recurse form))))))

(define-vector-type string string-tag string-tag-bits 0 true
                    (lambda (form) (list 'raw->fixnum () form))
                    (lambda (form) (list 'fixnum->raw () form)))
(define-vector-type vector vector-tag vector-tag-bits value-scale false
                    identity identity)

;;; Raw accesss to memory

(define raw-base-type-attrs
  (list (cons 'tag 0) (cons 'tag-bits 0) (cons 'header-size 0)))

(defmacro (define-raw-type name scale)
  (let* ((type-attrs (compound-symbol name "-type-attrs")))
    ;; define how to convert from the operators on a specific raw type
    ;; into generic raw operators
    (quasiquote (definitions
      (define (unquote type-attrs)
        (list* (cons 'scale (unquote scale))
               raw-base-type-attrs))

      (define-codegen-simplify ((unquote (compound-symbol name "-offset-ref"))
                                attrs addr index)
        (genericize-vec-op form 'raw-vec-ref (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-offset-set!"))
                                attrs addr index val)
        (genericize-vec-op form 'raw-vec-set! (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-ref"))
                                attrs addr)
        (genericize-vec-op form 'raw-ref (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-set!"))
                                attrs addr val)
        (genericize-vec-op form 'raw-set! (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-copy"))
                                attrs src-addr dest-addr len)
        (rplaca form 'copy-mem)
        (rplaca (cdr form) (unquote type-attrs))
        (codegen-simplify-recurse form))))))

(define-raw-type "raw-mem" value-scale)    ; memory as value-sized words
(define-raw-type "raw-mem-1" 0)            ; memory as bytes

;; Access to compiler constants for GC

(define compiler-constants
  (list (cons 'value-size value-size)
        (cons 'value-scale value-scale)
        (cons 'max-tag-bits max-tag-bits)
        (cons 'number-tag number-tag)
        (cons 'number-tag-bits number-tag-bits)
        (cons 'special-tag special-tag)
        (cons 'special-tag-bits special-tag-bits)
        (cons 'pair-tag pair-tag)
        (cons 'pair-tag-bits pair-tag-bits)
        (cons 'vector-tag vector-tag)
        (cons 'vector-tag-bits vector-tag-bits)
        (cons 'string-tag string-tag)
        (cons 'string-tag-bits string-tag-bits)
        (cons 'symbol-tag symbol-tag)
        (cons 'symbol-tag-bits symbol-tag-bits)
        (cons 'closure-tag closure-tag)
        (cons 'closure-tag-bits closure-tag-bits)
        (cons 'box-tag box-tag)
        (cons 'box-tag-bits box-tag-bits)))

(define (compiler-constant-value ccsym)
  (let* ((cc (assoc ccsym compiler-constants)))
    (unless cc (error "unknown compiler constant ~S" ccsym))
    (cdr cc)))

(define-codegen-simplify (compiler-constant ccsym)
  (overwrite-form form (list 'quote (compiler-constant-value ccsym))))

(define-codegen-simplify (fixnum->raw attrs val)
  (codegen-simplify val)
  (let* ((n (numberish-value val)))
    (when n (overwrite-form form (list 'raw n)))))

;;; We currently conflate character and numbers.  So eliminate
;;; character-related operators:

(define-codegen-simplify ((character-code code-character) attrs ch)
  (overwrite-form form ch)
  (codegen-simplify form))

(define-codegen-simplify (character? attrs ch)
  (rplaca form 'number?)
  (codegen-simplify form))

;;; Code generation for tail calls

(define (codegen-tail-call-shuffle cg attrs operands extra-assignments)
  (let* ((closure (and (attr-ref attrs 'needs-closure) (car operands)))

         ;; 'assignments' is what we want the stack to look like just
         ;; before the jump.  So it includes the return address, and
         ;; excludes the closure pointer.
         (out-arg-count (attr-ref attrs 'nargs))
         (assignments-count (+ out-arg-count (length extra-assignments)))
         (assignments (nconc extra-assignments
                             (if closure (cdr operands) operands)))

         (spare-regs
           (nthcdr (if closure (1+ out-arg-count) out-arg-count) operands))
         tmp-reg tmp-reg-2

         ;; The frame slot index at which the assignments start.
         ;; Parameter slots indices start at 0 and go down, so
         ;; -nparams represents the top of the frame.
         (orig-assignments-base (- assignments-count (attr-ref attrs 'nparams)))
         (assignments-base orig-assignments-base)

         (destinations false))
    ;; We need up to 3 temporary registers below (one to hold the
    ;; closure, and two for doing the assignments), but it is possible
    ;; that all registers are occupied by arguments.  So there are
    ;; cases where we need to spill some of those registers.  But such
    ;; cases are rare in practice rare (as I write this, the only
    ;; example is a test case deliberately designed to produce this
    ;; situation).  So we take the simple approach of spilling
    ;; up-front as needed to ensure we always have at least 3
    ;; registers available.
    (labels ((length-deficit (l n)
               (if (and (not (null? l)) (> n 0))
                   (length-deficit (cdr l) (1- n))
                   n))

             (spill (as n)
               (when (> n 0)
                 (spill-at-least-one as n)))

             (spill-at-least-one (as n)
               (when (null? as) (error "ran out of assignments to spill"))
               (let* ((reg (car as)))
                 (if (register? reg)
                     (begin
                       (emit-frame-push cg reg)
                       (set! spare-regs (cons reg spare-regs))
                       (rplaca as (frame-slot (codegen-frame-base cg)))
                       (spill (cdr as) (1- n)))
                     (spill-at-least-one (cdr as) n)))))

      (let* ((to-spill (length-deficit spare-regs 2)))
        (spill (cdr assignments) to-spill)))

    ;; Set closure early.  The caller is required to make sure that no
    ;; operands depend upon %closure.
    (when closure
      (emit-mov cg closure %closure))

    (set! tmp-reg (first spare-regs))
    (set! tmp-reg-2 (second spare-regs))

    ;; 'assignments' may imply an %sp lower than its current value.
    ;; By definition, these fresh slots cannot be the sources for
    ;; other slots, so we can push them onto the stack, eliminating
    ;; them from consideration.
    (labels ((assign-fresh-slots ()
               (when (> assignments-base (codegen-frame-base cg))
                 (let* ((a (car assignments)))
                   (set! assignments (cdr assignments))
                   (set! assignments-base (1- assignments-base))
                   (set! assignments-count (1- assignments-count))
                   (assign-fresh-slots)
                   (unless (acceptable-store-source? a)
                     (emit-mov cg a tmp-reg)
                     (set! a tmp-reg))
                   (emit-frame-push cg a)))))
      (assign-fresh-slots))

    ;; 'assignments' gives the values for a range of frame slots.
    ;; Some of these could be immediates, some could be registers, and
    ;; some could be frame slots.  To decide how to shuffle the frame
    ;; slots, we need to work out the destination frame slot (if any)
    ;; for each frame slots.  So here we find destinations for
    ;; assignments.
    (labels ((vector-push! (vec index head)
               (vector-set! vec index (cons head (vector-ref vec index))))

             (find-destinations (as dest)
               (when (< dest assignments-count)
                 (let* ((source (frame-slot-index (car as))))
                   (when source
                     ;; Convert from frame slot indices to indices
                     ;; into the outgoing arguments.
                     (set! source (- assignments-base source))

                     (cond ((= source dest)
                            ;; The source and destination are the
                            ;; same, so we can discard this assignment
                            (rplaca as false))

                           ((>= source 0)
                            ;; The source frame slot is also a
                            ;; destination.  We allocate the
                            ;; destinations vector lazily, because
                            ;; some tail calls won't need it.
                            (unless destinations
                              (set! destinations
                                    (make-vector assignments-count ())))
                            (vector-push! destinations source dest)))))

                 (find-destinations (cdr as) (1+ dest)))))
      (find-destinations assignments 0))

    (if (not destinations)
        ;; The easy case: there is no destinations vector, meaning
        ;; that all assignments are independent and so can be done
        ;; straightforwardly.
        (labels ((do-assignments-easy (as index)
                   (when (< index assignments-count)
                     (let* ((source (car as)))
                       (when source
                         ;; if the source is a memory operand, we need
                         ;; to copy via tmp-reg
                         (unless (acceptable-store-source? source)
                           (emit-mov cg source tmp-reg)
                           (set! source tmp-reg))

                         (emit-mov cg source
                                   (frame-slot (- assignments-base index)))))

                     (do-assignments-easy (cdr as) (1+ index)))))
          (do-assignments-easy assignments 0))

        ;; The hard case: There source of one assignment could be the
        ;; destination of another, and there might be cycles.  But
        ;; because a slot can only have a single source, there can
        ;; only be one cycle within a connected segment of the graph.
        ;; So we only need one register to break cycles.
        (labels ((assign (as index source-index)
                   (let* ((source (car as)))
                     (cond
                       ((not source)
                        ;; assignment has aleady been done, or is
                        ;; otherwise unnecessary
                        )

                       ((not (eq? 'current source))
                        ;; mark the assignment as in progress
                        (rplaca as 'current)

                        ;; before we overwrite this slot, assign any
                        ;; slots which take its value
                        (dolist (dest (vector-ref destinations index))
                          (assign (nthcdr dest assignments) dest index))

                        (cond
                          ;; Was the source preserved in tmp-reg-2 due
                          ;; to a cycle?
                          ((eq? 'cycle (car as))
                           (set! source tmp-reg-2))

                          ;; if the source is a memory operand, we
                          ;; need to copy via tmp-reg
                          ((not (acceptable-store-source? source))
                           (emit-mov cg source tmp-reg)
                           (set! source tmp-reg)))

                        ;; The actual assignment
                        (emit-mov cg source
                                  (frame-slot (- assignments-base index)))

                        ;; Mark the assignment done
                        (rplaca as false))

                       (true
                        ;; We have detected in an assignment cycle.
                        ;; Break the cycle by saving the source in
                        ;; tmp-reg-2.
                        (emit-mov cg
                                  (frame-slot (- assignments-base source-index))
                                  tmp-reg-2)
                        (rplaca as 'cycle)))))

                 (do-assignments (as index)
                   (when (< index assignments-count)
                     (assign as index 1000000)
                     (do-assignments (cdr as) (1+ index)))))
          (do-assignments assignments 0)))

    orig-assignments-base))
