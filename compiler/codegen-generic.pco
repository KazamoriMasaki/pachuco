;;; Code generation bits that aren't dependent on the target, the
;;; stack regime, the code generation strategy, or anything else

(define (codegen-push-out-of-line cg f)
  ;; When we push an out-of-line function, we need to save the
  ;; relevant coedegen state.  Currently this amounts to the
  ;; frame-base
  (codegen-set-out-of-line! cg (cons (cons f (codegen-frame-base cg))
                                     (codegen-out-of-line cg))))

(define (codegen-do-out-of-line cg)
  (let* ((ool (codegen-out-of-line cg)))
    (unless (null? ool)
      (codegen-set-frame-base! cg (cdar ool))
      (funcall (caar ool))
      (codegen-set-out-of-line! cg (cdr ool))
      (codegen-do-out-of-line cg))))

(define (fixnum-representation n) (ash n number-tag-bits))
(define (low-bits-mask bits) (1- (ash 1 bits)))

(define (emit-comment-form cg form)
  (unless (eq? 'begin (car form))
    (emit-comment cg "~S" (comment-form form))))

(define (make-registers-from-template template regs)
  (set! regs (copy-list regs))
  (dolist (reg template) (when reg (set! regs (delete reg regs))))
  (labels ((fill-template (template)
             (cond ((null? template)
                    regs)
                   ((car template)
                    (cons (car template) (fill-template (cdr template))))
                   (true
                    (let* ((r (car regs)))
                      (set! regs (cdr regs))
                      (cons r (fill-template (cdr template))))))))
    (fill-template template)))

;; Assembly utility functions

(define label-counter 0)

(define (gen-label)
  (format ".L~D" (set! label-counter (1+ label-counter))))

(define (label-name-ok? name i)
  (or (= i (string-length name))
      (let* ((ch (string-ref name i)))
        (and (or (character-alphanumeric? ch) (eq? ch #\-))
             (label-name-ok? name (1+ i))))))

(define (make-label-for sym prefix)
  ;; map a lisp symbol to an assembly label, returning a gen-labelled
  ;; label if necessary
  (let* ((name (subject-language-symbol-name sym)))
    (if (label-name-ok? name 0)
        (format "~A_~A" prefix (string-replace name "-" "_"))
        (format "~A~D" prefix (set! label-counter (1+ label-counter))))))

(define (emit-data cg label scale)
  (emit cg ".section .rodata")
  (emit-align cg scale)
  (emit cg "~A:" label))

(define (emit-bss-label cg label)
  (emit cg ".section .bss")
  (emit cg ".globl ~A" label)
  (emit cg "~A:" label))

(define (codegen-top-level-variable cg name label)
  (emit-comment cg "top-level ~S" name)
  (emit-bss-label cg label)
  (emit-literal cg 0))

(define (codegen-program-sections program cg)
  (emit cg ".section .bss")
  (emit-align cg value-scale)

  (emit-bss-label cg "top_level_start")

  (dolist (varrec (second program))
    (when (eq? 'arity-mismatch (car varrec))
      (codegen-set-arity-mismatch-varrec! cg varrec))

    (let* ((label (make-label-for (car varrec) variable-label-prefix)))
      (varrec-attr-set! varrec 'label label)
      (codegen-top-level-variable cg (car varrec) label)))

  (dolist (form (cddr program))
    (codegen-sections form cg)
    (emit-comment cg "BREAK"))

  (emit-bss-label cg "top_level_end"))

(define (codegen-function attrs cg)
  (let* ((labels (attr-ref attrs 'labels)))
    (emit cg ".text")
    (emit-align cg value-scale)
    (emit-literal cg (fixnum-representation
                       (1+ (length (attr-ref attrs 'closure)))))
    (emit cg ".globl ~A" (first labels))
    (emit-smart-label cg (first labels))

    (unless (null? (cdr labels))
      (let* ((nparams (length (attr-ref attrs 'params)))
             (bad-nargs-label (gen-label)))
        (emit-check-nargs cg nparams bad-nargs-label)
        (codegen-push-out-of-line cg
          (lambda ()
            (emit-smart-label cg bad-nargs-label)
            (emit-function-prologue cg)
            (trashy-codegen-discarding (quasiquote
               (tail-call ((nparams . 2))
                 (ref ((varrec . (unquote (codegen-arity-mismatch-varrec cg)))))
                 (quote ((quoted . (unquote nparams))))
                 (arg-count ())))
                                       cg false)))
        (emit cg ".globl ~A" (second labels))
        (emit-smart-label cg (second labels))))

    (emit-function-prologue cg)
    (when (codegen-have-closure cg) (emit-frame-push cg %closure))
    (trashy-codegen-discarding (attr-ref attrs 'body) cg false)
    (codegen-do-out-of-line cg)
    (emit cg ".size ~A, .-~A" (first labels) (first labels))))

(define (codegen-program-end cg)
  (codegen-helpers cg)
  (codegen-symbols cg)

  ;; This indicates to the linker that we support a non-executable stack
  (emit cg ".section .note.GNU-stack,\"\",%progbits"))

;;; "Smart" branching, jumping, and labels.
;;;
;;; These do some simple flow control optimizations.  For example,
;;;
;;;     (if (and A B) C D)
;;;
;;; which after macro-expansion is
;;;
;;;     (if (if A B false) C D)
;;;
;;; might naively yield
;;;
;;;     <code to yield A as boolean in CC1>
;;;     jnCC1 L1b ; branch to code for A false
;;;     jmp L1a   ; jump to code for A true
;;;
;;;     L1a:      ; A true
;;;     <code to yield B as boolean in CC2>
;;;     jnCC2 L2b ; branch to code for D
;;;     jmp L2a   ; branch to code for C
;;;     jmp L1c   ; unreachable branch to code after (if A B false)
;;;
;;;     L1b:      ; A false
;;;     jmp L2b   ; branch to code for D
;;;
;;;     L1c:      ; code following (if A B false) would go here...
;;;
;;;     L2a:
;;;     <code for C>
;;;     jmp L2c
;;;
;;;     L2b:
;;;     <code for D>
;;;
;;;     L2c:
;;;
;;; instead yields
;;;
;;;     <code to yield A as boolean in CC1>
;;;     jnCC1 L1b ; branch to code for A false
;;;
;;;     L1a:      ; A true
;;;     <code to yield B as boolean in CC2>
;;;     jnCC2 L2b ; branch to code for D
;;;
;;;     L2a:
;;;     <code for C>
;;;     jmp L2c
;;;
;;;     L1b:      ; A false
;;;     L2b:
;;;     <code for D>
;;;
;;;     L2c:
;;;
;;; The basic order of code is unchanged, but redundant jumps have
;;; been eliminated, and labels have been moved accordingly.  The key
;;; thing to notice here is that labels have all been moved later in
;;; the instruction stream.  This works because the compiler always
;;; generates jumps/branches forwards, never backwards.
;;;
;;; Thus we simply have to maintain a small amonut of state as we
;;; output instructions to tell us what special treatment is required
;;; for jumps, branches and labels.  This consists of three slots in
;;; the codegen object:
;;;
;;; - deferred-jump: A function representing the pending jump or
;;; branch, if any.  This function is called to emit the jump in
;;; flush-labels-and-jumps.  It's false when not optimising flow.
;;;
;;; - here-labels: The list of labels attached to the current point in
;;; the instruction stream.
;;;
;;; - redirect-labels: an alist from labels to the labels they
;;; redirect to.  We never change the label of a jump/branch; instead,
;;; when we emit a label, we also emit all the labels that redirect to
;;; it.

(define (emit-smart-jump cg label)
  (if (codegen-deferred-jump cg)
      (begin
        ;; there is no direct way to reach this jump, so all the here
        ;; labels now redirect to the jumped-to label
        (codegen-set-redirect-labels! cg
          (nconc (nmapfor (l (codegen-here-labels cg)) (cons l label))
                 (codegen-redirect-labels cg)))
        (codegen-set-here-labels! cg ()))
      (codegen-set-deferred-jump! cg
        (lambda ()
          ;; emit a jump, unless we are jumping to a here label
          (unless (member? label (codegen-here-labels cg))
            (emit-jump cg label))))))

(define (emit-smart-branch cg cc out-frame-base tlabel flabel)
  (emit-reset-frame-base cg out-frame-base)
  (flush-labels-and-jumps cg)
  (codegen-set-deferred-jump! cg
    (lambda ()
      (let* ((here-labels (codegen-here-labels cg)))
        (if (member? tlabel here-labels)
            (unless (member? flabel here-labels)
              (emit-branch cg (negate-cc cc) flabel))
            (begin
             (emit-branch cg cc tlabel)
             (unless (member? flabel here-labels)
               (emit-jump cg flabel))))))))

(define (emit-raw-label cg label)
  (emit-without-flushing "~A:" label))

(define (emit-smart-label cg label)
  (let* ((here-labels (cons label (nconc (codegen-here-labels cg)
                                         (take-merged-labels cg label)))))
    (if (codegen-deferred-jump cg)
        (codegen-set-here-labels! cg here-labels)
        (dolist (ml here-labels) (emit-raw-label cg ml)))))

(define (take-merged-labels cg label)
  ;; extract the labels which lead to label
  (let* ((res ()))
    (codegen-set-redirect-labels! cg
      (nfilterfor (redirect (codegen-redirect-labels cg))
        (if (eq? label (cdr redirect))
            (begin
              (push (car redirect) res)
              false)
            true)))
    res))

(define (flush-labels-and-jumps cg)
  (let* ((jump-func (codegen-deferred-jump cg)))
    (when jump-func
      (funcall jump-func)
      (let* ((here-labels (codegen-here-labels cg)))
        (if (null? here-labels)
            (emit-comment cg "unreachable")
            (dolist (l here-labels)
              (emit-without-flushing "~A:" l))))

      (codegen-set-deferred-jump! cg false)
      (codegen-set-here-labels! cg ()))))

(define (codegen-function-tail cg out-frame-base)
  ;; signals unreachable code after the tail form of a function,
  ;; e.g. after a return instruction, tail call, etc.  A tail form is
  ;; quite likely to have messed with the stack pointer, but we can
  ;; pretend for the sake of the context that it set it to the
  ;; expected value.
  (codegen-set-frame-base! cg out-frame-base)
  (unless (codegen-deferred-jump cg)
    (codegen-set-deferred-jump! cg (lambda ()))))

;;; Literals

(define-operator (raw) ()
  (attr-ref attrs 'value))

(define-codegen-sections (quote quoted)
  (rplaca (cdr form) (list (cons 'quoted quoted))))

(define (quote-false? form)
  (and (eq? 'quote (car form)) (eq? (form-attr form 'quoted) #f)))

(define-operator (quote) ()
  (let* ((val (codegen-quoted (attr-ref attrs 'quoted) cg)))
    ;;; If the quoted form resulted in a label, that means it emitted
    ;;; code, and we need to switch back to the code section
    (unless (number? val) (emit cg ".text"))
    val))

(define (codegen-quoted quoted cg)
  (cond ((pair? quoted) (codegen-quoted-pair quoted cg))
        ((number? quoted) (fixnum-representation quoted))
        ((character? quoted) (fixnum-representation (character-code quoted)))
        ((string? quoted) (codegen-quoted-string quoted cg))
        (true (let* ((c (assoc quoted simple-representations)))
             (cond (c (cdr c))
                   ((symbol? quoted) (codegen-quoted-symbol quoted cg))
                   (true (error "unrecognised quoted form ~S" quoted)))))))

(define (codegen-quoted-pair quoted cg)
  (let* ((label (gen-label))
         (a (codegen-quoted (car quoted) cg))
         (d (codegen-quoted (cdr quoted) cg)))
    (emit-data cg label pair-tag-bits)
    (emit-literal cg a)
    (emit-literal cg d)
    (format "~A+~D" label pair-tag)))

(define (codegen-quoted-string str cg)
  (let* ((label (gen-label)))
    (emit-data cg label string-tag-bits)
    (emit-literal cg (fixnum-representation (string-length str)))
    (emit cg ".ascii \"~A\"" (escape-string-literal str))
    (format "~A+~D" label string-tag)))

(define (escape-string-literal str)
  (string-replace (string-replace (string-replace str "\\" "\\\\")
                                  "\"" "\\\"") "
" "\\n"))

(define emitted-symbols (make-symboltable))
(define emitted-symbol-counter 0)

(define (codegen-quoted-symbol sym cg)
  (let* ((lit (symboltable-ref emitted-symbols sym)))
    (or lit
        (let* ((label (make-label-for sym symbol-label-prefix))
               (name (codegen-quoted-string (subject-language-symbol-name sym)
                                            cg)))
          (emit-data cg label symbol-tag-bits)
          (emit cg ".globl ~A" label)
          (emit-literal cg name)
          (emit-literal cg (fixnum-representation
                    (set! emitted-symbol-counter (1+ emitted-symbol-counter))))
          (set! lit (format "~A+~D" label symbol-tag))
          (symboltable-set! emitted-symbols sym lit)
          lit))))

(define (codegen-symbols cg)
  (emit-data cg "symbols_start" value-scale)
  (emit cg ".globl symbols_start")

  (let* ((sym-lits ()))
    (for-hashtable (sym lit emitted-symbols)
      (set! sym-lits (acons sym lit sym-lits)))

    (dolist (sym-lit (sort sym-lits (lambda (a b)
                                      (string< (symbol-name (car a))
                                               (symbol-name (car b))))))
      (emit-literal cg (cdr sym-lit))))

  (emit cg "symbols_end:")
  (emit cg ".global symbols_end"))

;;; Variables

(define-codegen-sections (define varrec val)
  ;; convert define for top-level variables to set!
  (when (varrec-top-level? varrec) (rplaca form 'set!))
  ;; make the varrec into a normal attribute, in order to use
  ;; define-operator
  (rplaca (cdr form) (acons 'varrec varrec ()))
  (codegen-sections val cg))

(define-codegen-sections ((set! ref) varrec . rest)
  ;; make the varrec into a normal attribute, in order to use
  ;; define-operator
  (rplaca (cdr form) (acons 'varrec varrec ()))
  (codegen-sections-forms rest cg))

;;; Simplifications of arithmetic operators

(define (simplify-binary-op form args identity)
  (simplify-recurse form)
  (cond ((null? args)
         (overwrite-form form (list 'quote identity)))
        ((null? (cdr args))
         (overwrite-form form (car args)))
        ((null? (cddr args))
         (when (eq? 'quote (caar args))
           (let* ((tmp (first args)))
             (rplaca args (second args))
             (rplaca (cdr args) tmp))))
        (true
         (overwrite-form form (reduce (car args) (cdr args)
                                (lambda (a b)
                                  (list* (car form) ()
                                         (if (eq? 'quote (car a))
                                             (list b a)
                                             (list a b)))))))))

(define-simplify (+ attrs . args) (simplify-binary-op form args 0))
(define-simplify (* attrs . args) (simplify-binary-op form args 1))

(define-simplify (- attrs a . args)
  (simplify-recurse form)
  (cond ((null? args) (rplaca form 'negate))
        ((not (null? (cdr args)))
         (overwrite-form form
                         (reduce a args (lambda (a b) (list '- () a b)))))))

(define-simplify ((eq? = /=) attrs a b)
  (simplify-recurse form)
  (when (eq? 'quote (car a))
    (overwrite-form form (list (car form) attrs b a))))

;; Distinguish the constant-bit-count for of ash from the
;; variable-bit-count form, because they lead to significantly
;; different code.
(define-codegen-sections (ash attrs n shift)
  (codegen-sections-recurse form cg)
  (when (eq? 'quote (car shift))
    (let* ((shiftval (form-attr shift 'quoted)))
      (when (number? shiftval)
        (overwrite-form form
          (cond ((= shiftval 0) n)
                ((<= shiftval (- value-bits))
                 (list 'ash-imm (acons 'shift (- 1 value-bits) attrs) n))
                ((< shiftval value-bits)
                 (list 'ash-imm (acons 'shift shiftval attrs) n))
                (true
                 (quasiquote (begin ()
                                    (unquote n)
                                    (quote ((quoted . 0))))))))))))

;;; Function calls

(define (func-lambda-attrs func)
  (cond ((eq? 'ref (first func))
         (let* ((l (varrec-attr-defaulting (varrec-origin (form-attr func 'varrec))
                                           'lambda false)))
           (and l (car l))))
        ((member? (first func) '(lambda static-lambda))
         (second func))
        (true
         false)))

(define (func-lambda-attr func attr if-not-resolved)
  (let* ((attrs (func-lambda-attrs func)))
    (if attrs
        (attr-ref-defaulting attrs attr if-not-resolved)
        if-not-resolved)))

(define (func-needs-closure? func)
  (not (null? (func-lambda-attr func 'closure true))))

(define (check-call-nargs lambda-attrs nargs)
  (let* ((expected (length (attr-ref lambda-attrs 'params)))
         (at-least ""))
    (when (if (attr-ref lambda-attrs 'vararg)
              (begin
                (set! at-least "at least ")
                (< nargs expected))
              (/= nargs expected))
      (let* ((varrec (attr-ref-defaulting lambda-attrs 'self false)))
        (error "bad number of arguments in call to ~A (expected ~A~D, got ~D)"
               (if varrec (car varrec) "anonymous function")
               at-least expected nargs)))))

(define (codegen-call-args cg func args)
  (dolist (arg (reverse args))
    (emit-frame-spill cg (trashy-codegen arg cg false)
                      (first general-registers)))
  (when (func-needs-closure? func)
    (trashy-codegen-into-reg func cg false %closure)))

(define-operator (static-lambda) ()
  (let* ((label (gen-label)))
    (emit-data cg label closure-tag-bits)
    (emit-literal cg (car (attr-ref attrs 'labels)))
    (emit cg ".text")
    (format "~A+~D" label closure-tag)))

(define-simplify (c-call c-function-name . args)
  (rplaca (cdr form) (list (cons 'c-function-name c-function-name)))
  (simplify-recurse form))

;;; Misc runtime support

(define-simplify (raw-label name)
  (rplaca (cdr form) (list (cons 'name name))))

(define-simplify (raw-global-ref name)
  (rplaca (cdr form) (list (cons 'name name))))

(define-simplify (raw-global-set! name val)
  (rplaca (cdr form) (list (cons 'name name))))

(define-simplify (raw-alloc tag-bits-ccsym size)
  (rplaca (cdr form) (list (cons 'tag-bits tag-bits-ccsym))))

;; raw-jump-with-arg-space and raw-apply-jump should always appear in
;; tail positions
(define-propagate ((raw-jump-with-arg-space raw-apply-jump) . rest))

;;; Misc utility functions

(define (trashy-codegen-into-regs cg forms regs)
  (labels ((codegen-forms (forms regs)
             (when (null? regs) (error "too many arguments for registers"))
             (if (null? (cdr forms))
                 (trashy-codegen-into-reg (car forms) cg false (car regs))
                 (begin
                   (emit-frame-spill cg (trashy-codegen (car forms) cg false)
                                     (car regs))
                   (codegen-forms (cdr forms) (cdr regs))
                   (emit-frame-pop cg (car regs))))))
    (unless (null? forms) (codegen-forms forms regs))))
