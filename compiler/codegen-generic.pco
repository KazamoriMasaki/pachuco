;;; Code generation bits that aren't dependent on the target, the
;;; stack regime, the code generation strategy, or anything else

(define (codegen-push-out-of-line cg f)
  ;; When we push an out-of-line function, we need to save the
  ;; relevant coedegen state.  Currently this amounts to the
  ;; frame-base
  (codegen-set-out-of-line! cg (cons (cons f (codegen-frame-base cg))
                                     (codegen-out-of-line cg))))

(define (codegen-do-out-of-line cg)
  (let* ((ool (codegen-out-of-line cg)))
    (unless (null? ool)
      (codegen-set-out-of-line! cg (cdr ool))
      (codegen-set-frame-base! cg (cdar ool))
      (funcall (caar ool))
      (codegen-do-out-of-line cg))))

(define (codegen-lambda-todo cg form)
  (codegen-set-todo! cg (cons form (codegen-todo cg))))

(define (codegen-do-todos cg)
  (let* ((todo (codegen-todo cg)))
    (unless (null? todo)
      (codegen-set-todo! cg (cdr todo))
      (codegen-function cg (car todo))
      (codegen-do-todos cg))))

(define (fixnum-representation n) (ash n number-tag-bits))
(define (low-bits-mask bits) (1- (ash 1 bits)))

(define (emit-comment-form cg form)
  (unless (eq? 'begin (car form))
    (emit-comment cg "~S" (comment-form form))))

(define (register-bitset regs)
  (reduce (register-bit (car regs)) (cdr regs)
          (lambda (bits reg) (logior bits (register-bit reg)))))

;; Assembly utility functions

(define (emit-data cg label scale)
  (emit cg ".section .rodata")
  (emit-align cg scale)
  (emit cg "~A:" label))

;;; Generate the prologue to the assembly output
(define (codegen-program-start cg program)
  (labels ((emit-label (label)
             (emit cg ".globl ~A" label)
             (emit cg "~A:" label)))
    (emit cg ".section .bss")
    (emit-align cg value-scale)
    (emit-label "top_level_start")

    (dolist (varrec (second program))
      (when (eq? 'arity-mismatch (varrec-name varrec))
        (codegen-set-arity-mismatch-varrec! cg varrec))

      (let* ((label (make-label-for (varrec-name varrec)
                                    variable-label-prefix)))
        (varrec-set-index! varrec label)
        (emit-comment cg "top-level ~S" (varrec-name varrec))
        (emit-label label)
        (emit-literal cg unspecified-representation)))

    (emit-label "top_level_end"))

  (codegen-set-have-closure! cg false))

;;; Finish off the assembly output
(define (codegen-program-end cg)
  (codegen-do-todos cg)
  (codegen-helpers cg)
  (codegen-symbols cg)

  ;; This indicates to the linker that we support a non-executable stack
  (emit cg ".section .note.GNU-stack,\"\",%progbits"))

(define (codegen-function cg form)
  (let* ((attrs (second form))
         (labels (attr-ref attrs 'labels))
         (closure (attr-ref attrs 'closure)))
    (labels ((assign-varrec-indices (varrecs)
               ;; assign slot indices to varrecs
               (let* ((index 0))
                 (dolist (varrec varrecs)
                   (varrec-set-index! varrec index)
                   (set! index (1+ index))))))
      (assign-varrec-indices closure)
      (assign-varrec-indices (attr-ref attrs 'params)))

    (emit cg ".text")
    (emit-align cg value-scale)
    (emit-literal cg (fixnum-representation (1+ (length closure))))
    (emit cg ".globl ~A" (first labels))
    (emit-smart-label cg (first labels))

    (let* ((self-varrec (attr-ref attrs 'self)))
      (when self-varrec
        (emit-comment cg "function ~S" (varrec-name self-varrec))))

    (unless (null? (cdr labels))
      (let* ((nparams (length (attr-ref attrs 'params)))
             (bad-nargs-label (gen-label)))
        (emit-check-nargs cg nparams bad-nargs-label)
        (codegen-push-out-of-line cg
          (lambda ()
            (emit-smart-label cg bad-nargs-label)
            (emit-function-prologue cg)
            (trashy-codegen-discarding (quasiquote
               (tail-call ((nparams . 2))
                 (ref ((varrec . (unquote (codegen-arity-mismatch-varrec cg)))))
                 (quote (unquote nparams))
                 (arg-count ())))
                                       cg false)))
        (emit cg ".globl ~A" (second labels))
        (emit-smart-label cg (second labels))))

    (emit-function-prologue cg)
    (codegen-set-have-closure! cg (if (null? closure)
                                      false
                                      (begin
                                        (emit-frame-push cg %closure)
                                        true)))
    (codegen-body cg (attr-ref attrs 'body) false)
    (codegen-do-out-of-line cg)
    (emit cg ".size ~A, .-~A" (first labels) (first labels))))

;;; Generate code for the body of a function or main program body
(define (codegen-body cg body out-frame-base)
  (codegen-simplify body)
  (emit-comment-form cg body)
  (trashy-codegen-discarding body cg out-frame-base))

;;; "Smart" branching, jumping, and labels.
;;;
;;; These do some simple flow control optimizations.  For example,
;;;
;;;     (if (and A B) C D)
;;;
;;; which after macro-expansion is
;;;
;;;     (if (if A B false) C D)
;;;
;;; might naively yield
;;;
;;;     <code to yield A as boolean in CC1>
;;;     jnCC1 L1b ; branch to code for A false
;;;     jmp L1a   ; jump to code for A true
;;;
;;;     L1a:      ; A true
;;;     <code to yield B as boolean in CC2>
;;;     jnCC2 L2b ; branch to code for D
;;;     jmp L2a   ; branch to code for C
;;;     jmp L1c   ; unreachable branch to code after (if A B false)
;;;
;;;     L1b:      ; A false
;;;     jmp L2b   ; branch to code for D
;;;
;;;     L1c:      ; code following (if A B false) would go here...
;;;
;;;     L2a:
;;;     <code for C>
;;;     jmp L2c
;;;
;;;     L2b:
;;;     <code for D>
;;;
;;;     L2c:
;;;
;;; instead yields
;;;
;;;     <code to yield A as boolean in CC1>
;;;     jnCC1 L1b ; branch to code for A false
;;;
;;;     L1a:      ; A true
;;;     <code to yield B as boolean in CC2>
;;;     jnCC2 L2b ; branch to code for D
;;;
;;;     L2a:
;;;     <code for C>
;;;     jmp L2c
;;;
;;;     L1b:      ; A false
;;;     L2b:
;;;     <code for D>
;;;
;;;     L2c:
;;;
;;; The basic order of code is unchanged, but redundant jumps have
;;; been eliminated, and labels have been moved accordingly.  The key
;;; thing to notice here is that labels have all been moved later in
;;; the instruction stream.  This works because the compiler always
;;; generates jumps/branches forwards, never backwards.
;;;
;;; Thus we simply have to maintain a small amonut of state as we
;;; output instructions to tell us what special treatment is required
;;; for jumps, branches and labels.  This consists of three slots in
;;; the codegen object:
;;;
;;; - deferred-jump: A function representing the pending jump or
;;; branch, if any.  This function is called to emit the jump in
;;; flush-labels-and-jumps.  It's false when not optimising flow.
;;;
;;; - here-labels: The list of labels attached to the current point in
;;; the instruction stream.
;;;
;;; - redirect-labels: an alist from labels to the labels they
;;; redirect to.  We never change the label of a jump/branch; instead,
;;; when we emit a label, we also emit all the labels that redirect to
;;; it.

(define (emit-smart-jump cg label)
  (if (codegen-deferred-jump cg)
      (begin
        ;; there is no direct way to reach this jump, so all the here
        ;; labels now redirect to the jumped-to label
        (codegen-set-redirect-labels! cg
          (nconc (nmapfor (l (codegen-here-labels cg)) (cons l label))
                 (codegen-redirect-labels cg)))
        (codegen-set-here-labels! cg ()))
      (codegen-set-deferred-jump! cg
        (lambda ()
          ;; emit a jump, unless we are jumping to a here label
          (unless (member? label (codegen-here-labels cg))
            (emit-jump cg label))))))

(define (emit-smart-branch cg cc out-frame-base tlabel flabel)
  (emit-reset-frame-base cg out-frame-base)
  (flush-labels-and-jumps cg)
  (codegen-set-deferred-jump! cg
    (lambda ()
      (let* ((here-labels (codegen-here-labels cg)))
        (if (member? tlabel here-labels)
            (unless (member? flabel here-labels)
              (emit-branch cg (negate-cc cc) flabel))
            (begin
             (emit-branch cg cc tlabel)
             (unless (member? flabel here-labels)
               (emit-jump cg flabel))))))))

(define (emit-raw-label cg label)
  (emit-without-flushing "~A:" label))

(define (emit-smart-label cg label)
  (let* ((here-labels (cons label (nconc (codegen-here-labels cg)
                                         (take-merged-labels cg label)))))
    (if (codegen-deferred-jump cg)
        (codegen-set-here-labels! cg here-labels)
        (dolist (ml here-labels) (emit-raw-label cg ml)))))

(define (take-merged-labels cg label)
  ;; extract the labels which lead to label
  (let* ((res ()))
    (codegen-set-redirect-labels! cg
      (nfilterfor (redirect (codegen-redirect-labels cg))
        (if (eq? label (cdr redirect))
            (begin
              (push (car redirect) res)
              false)
            true)))
    res))

(define (flush-labels-and-jumps cg)
  (let* ((jump-func (codegen-deferred-jump cg)))
    (when jump-func
      (funcall jump-func)
      (let* ((here-labels (codegen-here-labels cg)))
        (if (null? here-labels)
            (emit-comment cg "unreachable")
            (dolist (l here-labels)
              (emit-without-flushing "~A:" l))))

      (codegen-set-deferred-jump! cg false)
      (codegen-set-here-labels! cg ()))))

(define (codegen-function-tail cg out-frame-base)
  ;; signals unreachable code after the tail form of a function,
  ;; e.g. after a return instruction, tail call, etc.  A tail form is
  ;; quite likely to have messed with the stack pointer, but we can
  ;; pretend for the sake of the context that it set it to the
  ;; expected value.
  (codegen-set-frame-base! cg out-frame-base)
  (unless (codegen-deferred-jump cg)
    (codegen-set-deferred-jump! cg (lambda ()))))

;;; Literals

(define-operator (raw) ()
  (attr-ref attrs 'value))

(define (quote-false? form)
  (and (eq? 'quote (car form)) (eq? (second form) #f)))

(define-operator (quote) ()
  (let* ((val (codegen-quoted attrs cg)))
    ;;; If the quoted form resulted in a label, that means it emitted
    ;;; code, and we need to switch back to the code section
    (unless (number? val) (emit cg ".text"))
    val))

(defconstant positive-number-mask (1- (ash 1 (- value-bits number-tag-bits))))
(defconstant negative-number-mask (ash -1 (- value-bits number-tag-bits 1)))

;;; Normalize a number to fit in value-bits.  It's useful that this
;;; preserves the sign of the number, so that -1 remains -1 in the
;;; generated assembly.
(define (normalize-number n)
  (if (>= n 0)
      (logand n positive-number-mask)
      (logior n negative-number-mask)))

(define (codegen-quoted quoted cg)
  (cond ((pair? quoted) (codegen-quoted-pair quoted cg))
        ((number? quoted) (fixnum-representation (normalize-number quoted)))
        ((character? quoted) (fixnum-representation (character-code quoted)))
        ((string? quoted) (codegen-quoted-string quoted cg))
        (true (let* ((c (assoc quoted simple-representations)))
             (cond (c (cdr c))
                   ((symbol? quoted) (codegen-quoted-symbol quoted cg))
                   (true (error "unrecognised quoted form ~S" quoted)))))))

(define (codegen-quoted-pair quoted cg)
  (let* ((label (gen-label))
         (a (codegen-quoted (car quoted) cg))
         (d (codegen-quoted (cdr quoted) cg)))
    (emit-data cg label pair-tag-bits)
    (emit-literal cg a)
    (emit-literal cg d)
    (format "~A+~D" label pair-tag)))

(define (codegen-quoted-string str cg)
  (let* ((label (gen-label)))
    (emit-data cg label string-tag-bits)
    (emit-literal cg (fixnum-representation (string-length str)))
    (emit cg ".ascii \"~A\"" (escape-string-literal str))
    (format "~A+~D" label string-tag)))

(define (escape-string-literal str)
  (string-replace (string-replace (string-replace str "\\" "\\\\")
                                  "\"" "\\\"") "
" "\\n"))

(define emitted-symbols (make-symboltable))
(define emitted-symbol-counter 0)

(define (codegen-quoted-symbol sym cg)
  (let* ((lit (symboltable-ref emitted-symbols sym)))
    (or lit
        (let* ((label (make-label-for sym symbol-label-prefix))
               (name (codegen-quoted-string (subject-language-symbol-name sym)
                                            cg)))
          (emit-data cg label symbol-tag-bits)
          (emit cg ".globl ~A" label)
          (emit-literal cg name)
          (emit-literal cg (fixnum-representation
                    (set! emitted-symbol-counter (1+ emitted-symbol-counter))))
          (set! lit (format "~A+~D" label symbol-tag))
          (symboltable-set! emitted-symbols sym lit)
          lit))))

(define (codegen-symbols cg)
  (emit-data cg "symbols_start" value-scale)
  (emit cg ".globl symbols_start")

  (let* ((sym-lits ()))
    (for-hashtable (sym lit emitted-symbols)
      (set! sym-lits (acons sym lit sym-lits)))

    (dolist (sym-lit (sort sym-lits (lambda (a b)
                                      (string< (symbol-name (car a))
                                               (symbol-name (car b))))))
      (emit-literal cg (cdr sym-lit))))

  (emit cg "symbols_end:")
  (emit cg ".global symbols_end"))

;;; Stack handling

(define (emit-frame-push cg reg)
  (emit-push cg reg)
  (codegen-set-frame-base! cg (1+ (codegen-frame-base cg))))

(define (emit-frame-pop cg reg)
  (emit-pop cg reg)
  (codegen-set-frame-base! cg (1- (codegen-frame-base cg))))

(define (emit-reset-frame-base cg out-frame-base)
  (when out-frame-base
    (let* ((in-frame-base (codegen-frame-base cg)))
      (unless (= in-frame-base out-frame-base)
        (emit-offset-sp cg (- in-frame-base out-frame-base))
        (codegen-set-frame-base! cg out-frame-base)))))

;;; Variables

(define-codegen-simplify (define varrec val)
  ;; convert define for top-level variables to set!
  (when (varrec-top-level? varrec) (rplaca form 'set!))
  ;; make the varrec into a normal attribute, in order to use
  ;; define-operator
  (rplaca (cdr form) (acons 'varrec varrec ()))
  (codegen-simplify val))

(define-codegen-simplify ((set! ref) varrec . rest)
  ;; make the varrec into a normal attribute, in order to use
  ;; define-operator
  (rplaca (cdr form) (acons 'varrec varrec ()))
  (codegen-simplify-forms rest))

;;; Simplifications of arithmetic operators

(define (simplify-binary-op form args identity op)
  (codegen-simplify-recurse form)
  (cond ((null? args)
         (overwrite-form form (list 'quote identity)))
        ((null? (cdr args))
         (overwrite-form form (car args)))
        ((null? (cddr args))
         (let* ((a (first args)))
           (when (eq? 'quote (car a))
             (let* ((b (second args)))
               (if (eq? 'quote (car b))
                   ;; constant folding
                   (overwrite-form form
                           (list 'quote (funcall op (second a) (second b))))
                   ;; move a quoted arg to the second position, for
                   ;; better code generation
                   (begin
                    (rplaca args b)
                    (rplaca (cdr args) a)))))))
        (true
         (overwrite-form form (reduce (car args) (cdr args)
                                (lambda (a b)
                                  (list* (car form) ()
                                         (if (eq? 'quote (car a))
                                             (list b a)
                                             (list a b)))))))))

(define-codegen-simplify (+ attrs . args)
    (simplify-binary-op form args 0 (function +)))
(define-codegen-simplify (* attrs . args)
    (simplify-binary-op form args 1 (function *)))

(define-codegen-simplify (- attrs a . args)
  (codegen-simplify-recurse form)
  (cond ((null? args) (rplaca form 'negate))
        ((not (null? (cdr args)))
         (overwrite-form form
                         (reduce a args (lambda (a b) (list '- () a b)))))))

(define-codegen-simplify ((eq? = /=) attrs a b)
  (codegen-simplify-recurse form)
  ;; always move a quoted arg to the second position, for better code
  ;; generation
  (when (eq? 'quote (car a))
    (overwrite-form form (list (car form) attrs b a))))

;; Distinguish the constant-bit-count for of ash from the
;; variable-bit-count form, because they lead to significantly
;; different code.
(define-codegen-simplify (ash attrs n shift)
  (codegen-simplify-recurse form)
  (when (eq? 'quote (car shift))
    (let* ((shiftval (second shift)))
      (unless (number? shiftval) (error "ash with non-number"))

      (overwrite-form form
        (cond ((eq? 'quote (car n))
               (let* ((nval (second n)))
                 (unless (number? nval) (error "ash with non-number"))
                 (list 'quote (ash nval shiftval))))
              ((= shiftval 0)
               n)
              ((<= shiftval (- value-bits))
               (list 'ash-imm (acons 'shift (- 1 value-bits) attrs) n))
              ((< shiftval value-bits)
               (list 'ash-imm (acons 'shift shiftval attrs) n))
              (true
               (quasiquote (begin () (unquote n) (quote 0)))))))))

;;; Function calls

(define (func-lambda-attrs func)
  (cond ((eq? 'ref (first func))
         (let* ((l (varrec-lambda (varrec-origin (form-attr func 'varrec)))))
           (and l (second l))))
        ((member? (first func) '(lambda static-lambda))
         (second func))
        (true
         false)))

(define (func-lambda-attr func attr if-not-resolved)
  (let* ((attrs (func-lambda-attrs func)))
    (if attrs
        (attr-ref-defaulting attrs attr if-not-resolved)
        if-not-resolved)))

(define (func-needs-closure? func)
  (not (null? (func-lambda-attr func 'closure true))))

(define (check-call-nargs lambda-attrs nargs)
  (let* ((expected (length (attr-ref lambda-attrs 'params)))
         (at-least ""))
    (when (if (attr-ref lambda-attrs 'vararg)
              (begin
                (set! at-least "at least ")
                (< nargs expected))
              (/= nargs expected))
      (let* ((varrec (attr-ref-defaulting lambda-attrs 'self false)))
        (error "bad number of arguments in call to ~A (expected ~A~D, got ~D)"
               (if varrec (car varrec) "anonymous function")
               at-least expected nargs)))))

;; prepare-for-call does all the work to make calls to
;; statically-known functions fast:
;;
;; - Checking the number of arguments at compile time.
;;
;; - Storing the number of arguments in %nargs
;;
;; - Working out which label to branch to.
(define (prepare-for-call cg func nargs)
  (let* ((attrs (func-lambda-attrs func)))
    (if attrs
        (let* ((labels (attr-ref attrs 'labels)))
          (check-call-nargs attrs nargs)
          (if (null? (cdr labels))
              (begin
                (emit-mov cg (fixnum-representation nargs) %nargs)
                (first labels))
              (second labels)))
        (begin
          (emit-mov cg (fixnum-representation nargs) %nargs)
          false))))

(define (codegen-call-args cg func args)
  (dolist (arg (reverse args))
    (emit-frame-spill cg (trashy-codegen arg cg false)
                      (first general-registers)))
  (if (func-needs-closure? func)
      (trashy-codegen-into-reg func cg false %closure)
      (trashy-codegen-discarding func cg false)))

(define-operator (static-lambda) ()
  (codegen-lambda-todo cg form)
  (let* ((label (gen-label)))
    (emit-data cg label closure-tag-bits)
    (emit-literal cg (car (attr-ref attrs 'labels)))
    (emit cg ".text")
    (format "~A+~D" label closure-tag)))

(define-codegen-simplify (c-call c-function-name . args)
  (rplaca (cdr form) (list (cons 'c-function-name c-function-name)))
  (codegen-simplify-recurse form))

(define-operator (arg-count) () %nargs)

;;; Type check operators

(define-tag-check function? closure-tag closure-tag-bits)
(define-tag-check pair? pair-tag pair-tag-bits)
(define-tag-check symbol? symbol-tag symbol-tag-bits)
(define-tag-check number? number-tag number-tag-bits)
(define-tag-check string? string-tag string-tag-bits)
(define-tag-check vector? vector-tag vector-tag-bits)

;;; Misc runtime support

(define-codegen-simplify ((raw-label raw-global-ref) name)
  (rplaca (cdr form) (list (cons 'name name))))

(define-codegen-simplify (raw-global-set! name val)
  (codegen-simplify val)
  (rplaca (cdr form) (list (cons 'name name))))

(define-codegen-simplify (raw-alloc tag-bits-ccsym size)
  (codegen-simplify size)
  (rplaca (cdr form) (list (cons 'tag-bits tag-bits-ccsym))))

;; raw-jump-with-arg-space and raw-apply-jump should always appear in
;; tail positions
(define-propagate ((raw-jump-with-arg-space raw-apply-jump) . rest))

;;; Misc utility functions

(define (trashy-codegen-into-regs cg forms regs)
  (labels ((codegen-forms (forms regs)
             (when (null? regs) (error "too many arguments for registers"))
             (if (null? (cdr forms))
                 (trashy-codegen-into-reg (car forms) cg false (car regs))
                 (begin
                   (emit-frame-spill cg (trashy-codegen (car forms) cg false)
                                     (car regs))
                   (codegen-forms (cdr forms) (cdr regs))
                   (emit-frame-pop cg (car regs))))))
    (unless (null? forms) (codegen-forms forms regs))))

;;; String/vector support

(define (genericize-vec-op form name attrs)
  ;; convert a vector-type-specific operator into a generic vec operator
  (rplaca form name)
  (rplaca (cdr form) attrs)
  (codegen-simplify form))

(define (make-copy-mem-form src src-index dest dest-index len attrs)
  (quasiquote
    (copy-mem (unquote attrs)
              (vec-address (unquote attrs) (unquote src) (unquote src-index))
              (vec-address (unquote attrs) (unquote dest) (unquote dest-index))
              (unquote len))))

(defmacro (define-vector-type name tag tag-bits scale from-vec-rep to-vec-rep)
  (let* ((type-attrs (compound-symbol name "-type-attrs")))
    ;; define how to convert from the operators on a specific vector
    ;; type into generic vec operators
    (quasiquote (definitions
      (define (unquote type-attrs)
        (list (cons 'tag (unquote tag))
              (cons 'tag-bits (unquote tag-bits))
              (cons 'scale (unquote scale))
              (cons 'header-size value-size)))

      (define-codegen-simplify ((unquote (compound-symbol "make-" name))
                                attrs len init)
        (rplaca (cdddr form) ((unquote to-vec-rep) init))
        (genericize-vec-op form 'make-vec (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-length"))
                                attrs vec)
        (genericize-vec-op form 'vec-length (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-address"))
                                attrs vec index)
        (genericize-vec-op form 'vec-address (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-ref"))
                                attrs vec index)
        (genericize-vec-op form 'raw-vec-ref (unquote type-attrs))
        (overwrite-form form ((unquote from-vec-rep) (copy-list form))))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-set!"))
                                attrs vec index val)
        (rplaca (cddddr form) ((unquote to-vec-rep) val))
        (genericize-vec-op form 'raw-vec-set! (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol "raw-" name "-copy"))
                                attrs src src-index dest dest-index len)
        (overwrite-form form (make-copy-mem-form src src-index dest dest-index
                                                 len (unquote type-attrs)))
        (codegen-simplify-recurse form))))))

(define-vector-type string string-tag string-tag-bits 0
                    (lambda (form) (list 'raw->fixnum () form))
                    (lambda (form) (list 'fixnum->raw () form)))
(define-vector-type vector vector-tag vector-tag-bits value-scale
                    identity identity)

;;; Raw accesss to memory

(define raw-base-type-attrs
  (list (cons 'tag 0) (cons 'tag-bits 0) (cons 'header-size 0)))

(defmacro (define-raw-type name scale)
  (let* ((type-attrs (compound-symbol name "-type-attrs")))
    ;; define how to convert from the operators on a specific raw type
    ;; into generic raw operators
    (quasiquote (definitions
      (define (unquote type-attrs)
        (list* (cons 'scale (unquote scale))
               raw-base-type-attrs))

      (define-codegen-simplify ((unquote (compound-symbol name "-offset-ref"))
                                attrs addr index)
        (genericize-vec-op form 'raw-vec-ref (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-offset-set!"))
                                attrs addr index val)
        (genericize-vec-op form 'raw-vec-set! (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-ref"))
                                attrs addr)
        (genericize-vec-op form 'raw-ref (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-set!"))
                                attrs addr val)
        (genericize-vec-op form 'raw-set! (unquote type-attrs)))

      (define-codegen-simplify ((unquote (compound-symbol name "-copy"))
                                attrs src-addr dest-addr len)
        (rplaca form 'copy-mem)
        (rplaca (cdr form) (unquote type-attrs))
        (codegen-simplify-recurse form))))))

(define-raw-type "raw-mem" value-scale)    ; memory as value-sized words
(define-raw-type "raw-mem-1" 0)            ; memory as bytes

;; Access to compiler constants for GC

(define compiler-constants
  (list (cons 'value-size value-size)
        (cons 'value-scale value-scale)
        (cons 'number-tag number-tag)
        (cons 'number-tag-bits number-tag-bits)
        (cons 'special-tag special-tag)
        (cons 'special-tag-bits special-tag-bits)
        (cons 'pair-tag pair-tag)
        (cons 'pair-tag-bits pair-tag-bits)
        (cons 'vector-tag vector-tag)
        (cons 'vector-tag-bits vector-tag-bits)
        (cons 'string-tag string-tag)
        (cons 'string-tag-bits string-tag-bits)
        (cons 'symbol-tag symbol-tag)
        (cons 'symbol-tag-bits symbol-tag-bits)
        (cons 'closure-tag closure-tag)
        (cons 'closure-tag-bits closure-tag-bits)
        (cons 'box-tag box-tag)
        (cons 'box-tag-bits box-tag-bits)))

(define (compiler-constant-value ccsym)
  (let* ((cc (assoc ccsym compiler-constants)))
    (unless cc (error "unknown compiler constant ~S" ccsym))
    (cdr cc)))

(define-codegen-simplify (compiler-constant ccsym)
  (overwrite-form form (list 'quote (compiler-constant-value ccsym))))

;;; We currently conflate character and numbers.  So eliminate
;;; character-related operators:

(define-codegen-simplify ((character-code code-character) attrs ch)
  (overwrite-form form ch)
  (codegen-simplify form))

(define-codegen-simplify (character? attrs ch)
  (rplaca form 'number?)
  (codegen-simplify form))
