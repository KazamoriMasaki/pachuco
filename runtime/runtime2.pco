;;; common runtime definitions, even when bootstrapping from CL

(define (compound-symbol . pieces)
  (intern (string-flatten (mapfor (p pieces)
                            (cond ((string? p) (string-symbolcase p))
                                  ((symbol? p) (symbol-name p))
                                  (true (error "~S" p)))))))

;;; Simple struct support - just vectors with accessor functions

(define (struct-field-initializers fields n)
  (if (null? fields) ()
      (let* ((field (car fields))
             (rest (struct-field-initializers (cdr fields) (1+ n))))
        (if (pair? field)
            (cons (quasiquote
                    (raw-vector-set! s (unquote n) (unquote (second field))))
                  rest)
            rest))))

(define (struct-accessor-definitions struct fields n)
  (if (null? fields) ()
      (let* ((field (car fields))
             (field-name (if (pair? field) (first field) field)))
        (list*
          (quasiquote
            (define ((unquote (compound-symbol struct "-" field-name)) s)
              (raw-vector-ref s (unquote n))))

          (quasiquote
            (define ((unquote (compound-symbol struct "-set-" field-name "!"))
                     s val)
              (raw-vector-set! s (unquote n) val)))

          (struct-accessor-definitions struct (cdr fields) (1+ n))))))

(define (struct-field-position f fields n)
  (let* ((field (car fields)))
    (if (eq? f (if (pair? field) (car fields) field))
        n
        (struct-field-position f (cdr fields) (1+ n)))))

(defmarco (define-struct struct options . fields)
  (let* ((num-fields (length fields))
         (constr-opt (assoc 'constructor options))
         (constr-name (if constr-opt
                          (second constr-opt)
                          (compound-symbol "make-" struct)))
         (constr-params (if constr-opt
                            (cddr constr-opt)
                            ())))
    (quasiquote (definitions
      (define ((unquote constr-name) (unquote-splicing constr-params))
        (let* ((s (make-vector (unquote num-fields))))
          (unquote-splicing (struct-field-initializers fields 0))
          (unquote-splicing
           (mapfor (cp constr-params)
             (list 'raw-vector-set! 's (struct-field-position cp fields 0) cp)))
          s))

      (unquote-splicing (struct-accessor-definitions struct fields 0))))))

;;; hash tables

(defconstant hashtable-initial-size 11)

(define-struct hashtable ((constructor make-hashtable hashf equalf))
  hashf
  equalf
  (buckets (let* ((buckets (make-vector hashtable-initial-size)))
             (vector-set-range! buckets 0 hashtable-initial-size false)
             buckets))
  (size 0))

(define-struct ht-entry ((constructor make-ht-entry key value hash next))
  key
  value
  hash
  next)

(define (ht-entry-find key hte equalf)
  (and hte
       (if (funcall equalf key (ht-entry-key hte))
           hte
           (ht-entry-find key (ht-entry-next hte) equalf))))

(define (hashtable-ref ht key)
  (let* ((buckets (hashtable-buckets ht))
         (index (mod (funcall (hashtable-hashf ht) key) 
                     (vector-length buckets)))
         (hte (ht-entry-find key (vector-ref buckets index)
                             (hashtable-equalf ht))))
    (and hte (ht-entry-value hte))))

(define (hashtable-set! ht key value)
  (when (>= (* 2 (hashtable-size ht)) (vector-length (hashtable-buckets ht)))
    (hashtable-grow ht))

  (let* ((keyhash (funcall (hashtable-hashf ht) key))
         (buckets (hashtable-buckets ht))
         (index (mod keyhash (vector-length buckets)))
         (bucket (vector-ref buckets index))
         (hte (ht-entry-find key bucket (hashtable-equalf ht))))
    (if hte
        (ht-entry-set-value! hte value)
        (begin
          (hashtable-set-size! ht (1+ (hashtable-size ht)))
          (vector-set! buckets index
                       (make-ht-entry key value keyhash bucket))))))

(define (hashtable-grow ht)
  (let* ((buckets (hashtable-buckets ht))
         (new-buckets-len (1+ (* 2 (vector-length buckets))))
         (new-buckets (make-vector new-buckets-len)))
    (vector-set-range! new-buckets 0 (vector-length new-buckets) false)
    (labels ((rehash-hte (hte)
               (when hte
                 (let* ((index (mod (ht-entry-hash hte) new-buckets-len))
                        (next (ht-entry-next hte)))
                   (ht-entry-set-next! hte (vector-ref new-buckets index))
                   (vector-set! new-buckets index hte)
                   (rehash-hte next))))

             (rehash-bucket (index)
               (when (< index (vector-length buckets))
                 (rehash-hte (vector-ref buckets index))
                 (rehash-bucket (1+ index)))))
      (rehash-bucket 0))
    (hashtable-set-buckets! ht new-buckets)))

(define (string-hash str)
  (string-range-hash str 0 (string-length str)))

(define (string-range-hash str index len)
  (labels ((scan (len mult hash)
             (if (= len 0) hash
               (scan (1- len) (* 31 mult)
                     (+ hash (* mult (character-code
                                        (string-ref str (+ index len -1)))))))))
    (scan len 1 0)))
