;;; common runtime definitions, even when bootstrapping from CL

(define (compound-symbol . pieces)
  (intern (string-flatten (mapfor (p pieces)
                            (cond ((string? p) (string-symbolcase p))
                                  ((symbol? p) (symbol-name p))
                                  (true (error "~S" p)))))))

(define (list-repeating el len)
  (if (= 0 len) ()
      (cons el (list-repeating el (1- len)))))

;;; Simple option list support
;;;
;;; The options-bind macro takes an options specification
;;; (option-specs, unevaluated), an options list (evaluated), and a
;;; body (evaluated).  Each option-spec creates a variable binding,
;;; and indicates how to obtain the value from the options list.
;;;
;;; Each option (element of the evaluated options list) denotes an
;;; option name and a value as follows: If the option is a symbol, its
;;; name is the symbol, and its value is true.  If the option is a
;;; list, its name is in the car, and its value is the cdr.  Only one
;;; option may appear for a given option name.
;;;
;;; Each option-spec is a list of length two, giving the option name
;;; and default value.  It creates a binding of a variable with the
;;; option name to the value given by the option with the same name,
;;; or the default value if no such option appears.

(defmarco (options-bind option-specs options . body)
  (let* ((opts-state (gensym))          ; the state of each option
         (opt (gensym))                 ; the option being considered
         (name (gensym))                ; the option name
         (val (gensym))                 ; the option value
         (state (gensym)))              ; state of the current option
    (quasiquote
      (let* (((unquote opts-state)
              (list (unquote-splicing
                      (mapfor (os option-specs)
                        (quasiquote (list* '(unquote (first os)) false
                                           (unquote (second os)))))))))
        (dolist ((unquote opt) (unquote options))
          (let* (((unquote val) true)
                 ((unquote name) (if (pair? (unquote opt))
                                     (begin (set! (unquote val)
                                                  (cdr (unquote opt)))
                                            (car (unquote opt)))
                                     (unquote opt)))
                 ((unquote state) (assoc (unquote name) (unquote opts-state))))
            (unless (unquote state)
              (error "unknown option ~S" (unquote name)))
            (when (second (unquote state))
              (error "repeated option ~S" (unquote name)))
            (rplaca (cdr (unquote state)) true)
            (rplacd (cdr (unquote state)) (unquote val))))
        (bind (unquote (mapfor (os option-specs) (first os)))
              (nmapfor (x (unquote opts-state)) (cddr x))
          (unquote-splicing body))))))

;;; Simple struct support - just vectors with accessor functions

(define (struct-field-initializers fields n)
  (if (null? fields) ()
      (let* ((field (car fields))
             (rest (struct-field-initializers (cdr fields) (1+ n))))
        (if (pair? field)
            (cons (quasiquote
                    (raw-vector-set! s (unquote n) (unquote (second field))))
                  rest)
            rest))))

(define (struct-accessor-definitions struct fields n)
  (if (null? fields) ()
      (let* ((field (car fields))
             (field-name (if (pair? field) (first field) field)))
        (list*
          (quasiquote
            (define ((unquote (compound-symbol struct "-" field-name)) s)
              (raw-vector-ref s (unquote n))))

          (quasiquote
            (define ((unquote (compound-symbol struct "-set-" field-name "!"))
                     s val)
              (raw-vector-set! s (unquote n) val)))

          (struct-accessor-definitions struct (cdr fields) (1+ n))))))

(define (struct-field-position f fields n)
  (let* ((field (car fields)))
    (if (eq? f (if (pair? field) (car fields) field))
        n
        (struct-field-position f (cdr fields) (1+ n)))))

(defmarco (define-struct struct options . fields)
  (options-bind ((constructor false)) options
    (let* ((num-fields (length fields))
           (constr-name (if constructor
                            (first constructor)
                            (compound-symbol "make-" struct)))
           (constr-params (if constructor
                              (cdr constructor)
                              ())))
      (quasiquote (definitions
        (define ((unquote constr-name) (unquote-splicing constr-params))
            (let* ((s (make-vector (unquote num-fields))))
              (unquote-splicing (struct-field-initializers fields 0))
              (unquote-splicing
                (mapfor (cp constr-params)
                  (list 'raw-vector-set! 's
                        (struct-field-position cp fields 0) cp)))
              s))

        (unquote-splicing (struct-accessor-definitions struct fields 0)))))))

;;; hash tables

(defconstant hashtable-initial-size 11)

(define-struct hashtable ((constructor make-hashtable hashf equalf))
  hashf
  equalf
  (buckets (let* ((buckets (make-vector hashtable-initial-size)))
             (vector-set-range! buckets 0 hashtable-initial-size false)
             buckets))
  (size 0))

(define-struct ht-entry ((constructor make-ht-entry key value hash next))
  key
  value
  hash
  next)

(define (ht-entry-find key hte equalf)
  (and hte
       (if (funcall equalf key (ht-entry-key hte))
           hte
           (ht-entry-find key (ht-entry-next hte) equalf))))

(define (hashtable-ref ht key)
  (let* ((buckets (hashtable-buckets ht))
         (index (mod (funcall (hashtable-hashf ht) key) 
                     (vector-length buckets)))
         (hte (ht-entry-find key (vector-ref buckets index)
                             (hashtable-equalf ht))))
    (and hte (ht-entry-value hte))))

(define (hashtable-set! ht key value)
  (when (>= (* 2 (hashtable-size ht)) (vector-length (hashtable-buckets ht)))
    (hashtable-grow ht))

  (let* ((keyhash (funcall (hashtable-hashf ht) key))
         (buckets (hashtable-buckets ht))
         (index (mod keyhash (vector-length buckets)))
         (bucket (vector-ref buckets index))
         (hte (ht-entry-find key bucket (hashtable-equalf ht))))
    (if hte
        (ht-entry-set-value! hte value)
        (begin
          (hashtable-set-size! ht (1+ (hashtable-size ht)))
          (vector-set! buckets index
                       (make-ht-entry key value keyhash bucket))))))

(define (hashtable-grow ht)
  (let* ((buckets (hashtable-buckets ht))
         (new-buckets-len (1+ (* 2 (vector-length buckets))))
         (new-buckets (make-vector new-buckets-len)))
    (vector-set-range! new-buckets 0 (vector-length new-buckets) false)
    (labels ((rehash-hte (hte)
               (when hte
                 (let* ((index (mod (ht-entry-hash hte) new-buckets-len))
                        (next (ht-entry-next hte)))
                   (ht-entry-set-next! hte (vector-ref new-buckets index))
                   (vector-set! new-buckets index hte)
                   (rehash-hte next))))

             (rehash-bucket (index)
               (when (< index (vector-length buckets))
                 (rehash-hte (vector-ref buckets index))
                 (rehash-bucket (1+ index)))))
      (rehash-bucket 0))
    (hashtable-set-buckets! ht new-buckets)))

(define (string-hash str)
  (string-range-hash str 0 (string-length str)))

(define (string-range-hash str index len)
  (labels ((scan (len mult hash)
             (if (= len 0) hash
               (scan (1- len) (* 31 mult)
                     (+ hash (* mult (character-code
                                        (string-ref str (+ index len -1)))))))))
    (scan len 1 0)))
