;;; Runtime and library of basic definitions

(defmacro (when-compiling . rest)
  (if compiling (cons 'definitions rest) '(definitions)))
(defmacro (when-interpreting . rest)
  (if compiling '(definitions) (cons 'definitions rest)))

;;; Basics needed by quasiquote

(define (list . l) l)
(defmacro (list . l)
  (define (liszt . l) l)
  (define (aux l)
    (if (eq? () l) ()
        (liszt 'cons (car l) (aux (cdr l)))))
  (aux l))

(defmacro (caar x) (list 'car (list 'car x)))
(defmacro (cadr x) (list 'car (list 'cdr x)))
(defmacro (cdar x) (list 'cdr (list 'car x)))
(defmacro (cddr x) (list 'cdr (list 'cdr x)))
(defmacro (cadar x) (list 'car (list ' cdr (list 'car x))))
(defmacro (cdddr x) (list 'cdr (list ' cdr (list 'cdr x))))
(defmacro (cddddr x) (list 'cdr (list 'cdr (list 'cdr (list 'cdr x)))))

(defmacro (first x) (list 'car x))
(defmacro (second x) (list 'car (list 'cdr x)))
(defmacro (third x) (list 'car (list 'cdr (list 'cdr x))))
(defmacro (fourth x) (list 'car (list 'cdr (list 'cdr (list 'cdr x)))))

(defmacro (null? x) (list 'eq? () x))

(define (reduce initial l op)
  (if (null? l) initial
      (reduce (op initial (car l)) (cdr l) op)))

(defmacro (and . args)
  (if (null? args) true
      (if (null? (cdr args)) (car args)
          (reduce (car args) (cdr args) (lambda (a b) (list 'if a b false))))))

(defmacro (cond . clauses)
  (if (null? clauses) '(begin)
      (list 'if (caar clauses) (cons 'begin (cdar clauses))
            (cons 'cond (cdr clauses)))))

;;; Quasiquote and prerequisites

(define (quasiquote-transform innermost form)
  (cond ((pair? form)
         (define keyword (car form))
         (cond ((eq? 'unquote keyword)
                (if innermost (cadr form)
                    (list 'list '(quote quote) (cadr form))))
               ((eq? 'quasiquote keyword)
                (quasiquote-transform false
                                  (quasiquote-transform innermost (cadr form))))
               ((and (pair? keyword) (eq? 'unquote-splicing (car keyword)))
                (list 'append (cadr keyword)
                      (quasiquote-transform innermost (cdr form))))
               (true
                (list 'cons (quasiquote-transform innermost keyword)
                            (quasiquote-transform innermost (cdr form))))))
        ((symbol? form)
         (list 'quote form))
        (true form)))

(defmacro (quasiquote form)
  (quasiquote-transform true form))

(define (append-2 c l1 rest)
  ;; Attach elements from the list l1 and list of lists rest onto the cons c
  (if (null? l1)
      (begin
        (define l2 (car rest))
        (define rest2 (cdr rest))
        (if (null? rest2)
          (rplacd c l2) ; only one more list, so stick it on the end
          (append-2 c l2 rest2)))
      (begin
        (define c2 (cons (car l1) ()))
        (rplacd c c2)
        (append-2 c2 (cdr l1) rest))))

(define (append-1 lists)
  ;; Finds the first non-empty list, and hands over to append-2
  (define l1 (car lists))
  (define rest (cdr lists))
  (if (null? rest) l1 ; only one list, so that is the answer
      (if (null? l1) (append-1 rest) ; list empty, move on to the next
          (begin
            (define c (cons (car l1) ()))
            (append-2 c (cdr l1) rest)
            c))))

(define (append . lists)
  (if (null? lists) ()
      (append-1 lists)))

;;; Reified builtins

(defmacro (reify form)
  (quasiquote (define (unquote form) (unquote form))))

(reify (eq? a b))
(reify (function? a))

(reify (symbol? a))
(reify (symbol-name a))
(reify (symbol-id a))

(reify (pair? a))
(reify (null? a))
(reify (car a))
(reify (cdr a))
(reify (cons a b))
(reify (rplaca a b))
(reify (rplacd a b))

(reify (number? a))
(reify (< a b))
(reify (<= a b))
(reify (> a b))
(reify (>= a b))
(reify (= a b))
(reify (/= a b))

(define (+ . args)
  (if (null? args) 0
      (if (null? (cdr args)) (car args)
          (reduce (car args) (cdr args) (lambda (a b) (+ a b))))))

(define (* . args)
  (if (null? args) 1
      (if (null? (cdr args)) (car args)
          (reduce (car args) (cdr args) (lambda (a b) (* a b))))))

(define (- a . args)
  (if (null? args) (- a)
      (reduce a args (lambda (a b) (- a b)))))

(reify (rem a b))
(reify (truncate a b))
(reify (logand a b))
(reify (logior a b))
(reify (logxor a b))

(reify (character? a))
(reify (character-code a))
(reify (code-character a))

(reify (string? a))
(reify (make-string a init))
(reify (string-length a))

(reify (vector? a))
(reify (make-vector a init))
(reify (vector-length a))

(when-interpreting
  ;; Provide function forms for some interpreter builtins
  (reify (error-halt))
  (reify (intern a))

  ;; Gensym is an interesting case.  We need it early on for macros.
  ;; So when interpreting, we get it from the host.  When compiling,
  ;; we introduce it much later
  (reify (gensym)))

;;; Numbers

(defmacro (1- n) (quasiquote (- (unquote n) 1)))
(defmacro (1+ n) (quasiquote (+ (unquote n) 1)))

;;; Booleans

(defmacro (not a) (quasiquote (if (unquote a) false true)))

(defmacro (or . args)
  (if (null? args) false
      (if (null? (cdr args)) (car args)
          (reduce (car args) (cdr args)
                  (lambda (a b)
                    (define tmp (gensym))
                    (quasiquote (begin (define (unquote tmp) (unquote a))
                                       (if (unquote tmp) (unquote tmp)
                                           (unquote b)))))))))

(defmacro (when test . rest)
  (quasiquote (if (unquote test) (begin (unquote-splicing rest)))))

(defmacro (unless test . rest)
  (quasiquote (if (not (unquote test)) (begin (unquote-splicing rest)))))

;;; Control structures

(defmacro (while test . rest)
  (define name (gensym))
  (quasiquote (begin
               (define ((unquote name))
                   (when (unquote test)
                     (unquote-splicing rest)
                     ((unquote name))))
               ((unquote name)))))

(defmacro (until test . rest)
  (quasiquote (while (not (unquote test)) (unquote-splicing rest))))

(define (identity x) x)

;;; Compiled code support

;;; The real definition of error requires formatted output, which is a
;;; bit late in the day.  So put a stub definition in place here.
(define (error message . args)
  (error-halt))

(when-compiling
  (define (error-halt)
    (c-call "abort"))

  (define (arity-mismatch nparams nargs)
    (error "expected ~S arguments, got ~S" nparams nargs))

  (define (handle-varargs nparams nargs args-base)
    (when (< nargs nparams)
        (error "expected at least ~S arguments, got ~S" nparams nargs))

    (define (make-varargs-list nargs l)
      (if (/= nargs nparams)
          (make-varargs-list (1- nargs)
                             (cons (raw-vec-ref args-base (1- nargs)) l))
          l))

    (make-varargs-list nargs ()))

  (define (apply func arg1 . args)
    (define (count-args args)
      (if (null? (cdr args)) (length (car args))
          (1+ (count-args (cdr args)))))

    (define (copy-final-args args args-base index)
      (unless (null? args)
        (raw-vec-set! args-base index (car args))
        (copy-final-args (cdr args) args-base (1+ index))))

    (define (copy-args args args-base index)
      (if (null? (cdr args)) (copy-final-args (car args) args-base index)
          (begin
            (raw-vec-set! args-base index (car args))
            (copy-args (cdr args) args-base (1+ index)))))

    (set! args (cons arg1 args))
    (define arg-count (count-args args))
    (raw-jump-with-arg-space raw-arg-count arg-count
      (lambda ()
        (copy-args args (raw-args-base) 0)
        (raw-apply-jump func arg-count)))))

;;; Lists

(define (length-aux l n)
  (if (null? l) n (length-aux (cdr l) (1+ n))))

(define (length l)
  (length-aux l 0))

(define (member? item l)
  (cond ((null? l) false)
        ((eq? item (car l)) true)
        (true (member? item (cdr l)))))

(define (adjoin item l)
  (if (member? item l) l (cons item l)))

(define (elt l index)
  (if (= 0 index) (car l) (elt (cdr l) (1- index))))

(define (nthcdr index l)
  (if (= 0 index) l (nthcdr (1- index) (cdr l))))

(define (last-n-conses l n)
  (define (aux l)
    (if (null? l) ()
        (begin
          (define res (aux (cdr l)))
          (if (= n 0) res
              (begin
                (set! n (1- n))
                l)))))
  (aux l))

(define (last-cons l)
  (last-n-conses l 1))

(define (last-elem l)
  (car (last-cons l)))

(define (list* l1 . l)
  (if (null? l) l1
    (begin
      (set! l (cons l1 l))
      (define penultimate (last-n-conses l 2))
      (rplacd penultimate (cadr penultimate))
      l)))

(defmacro (list* l1 . l)
  (define (aux l1 l)
    (if (null? l) l1
        (quasiquote (cons (unquote l1) (unquote (aux (car l) (cdr l)))))))
  (aux l1 l))

(define (copy-list l)
  (if (pair? l) (cons (car l) (copy-list (cdr l))) l))

(define (copy-tree l)
  (if (pair? l)
      (cons (copy-tree (car l)) (copy-tree (cdr l)))
      l))

(define (flatten* ls)
  (define (find-end l ls)
    (if (null? (cdr l))
        (find-start l ls)
        (find-end (cdr l) ls)))

  (define (find-start l ls)
    (unless (null? ls)
      (if (null? (car ls))
          (find-start l (cdr ls))
          (begin
            (rplacd l (car ls))
            (find-end (car ls) (cdr ls))))))

  (if (null? ls) ()
      (if (null? (car ls))
          (flatten* (cdr ls))
          (begin
            (find-end (car ls) (cdr ls))
            (car ls)))))

(define (nconc . ls)
  (flatten* ls))

(defmacro (dolist binding . body)
  (define l (gensym))
  (quasiquote
    (begin
      (define (unquote l) (unquote (second binding)))
      (until (null? (unquote l))
        (begin
          (define (unquote (first binding)) (car (unquote l)))
          (unquote-splicing body))
        (set! (unquote l) (cdr (unquote l)))))))

(defmacro (mapfor binding . body)
  (define bodyf (gensym))
  (define loopf (gensym))
  (define in (gensym))
  (define out (gensym))
  (define tail (gensym))
  (quasiquote (begin
    (define (unquote in) (unquote (second binding)))
    (if (null? (unquote in)) ()
        (begin
          (define ((unquote bodyf) (unquote (first binding)))
              (unquote-splicing body))

          (define (unquote out)
              (cons ((unquote bodyf) (car (unquote in))) ()))
          (define (unquote tail) (unquote out))
          (define ((unquote loopf) (unquote in))
            (unless (null? (unquote in))
              (define (unquote out)
                  (cons ((unquote bodyf) (car (unquote in))) ()))
              (rplacd (unquote tail) (unquote out))
              (set! (unquote tail) (unquote out))
              ((unquote loopf) (cdr (unquote in)))))

          ((unquote loopf) (cdr (unquote in)))
          (unquote out))))))

(defmacro (nmapfor binding . body)
  (define loopf (gensym))
  (define l (gensym))
  (quasiquote (begin
    (define ((unquote loopf) (unquote l))
      (unless (null? (unquote l))
        (define (unquote (first binding)) (car (unquote l)))
        (rplaca (unquote l) (begin (unquote-splicing body)))
        ((unquote loopf) (cdr (unquote l)))))
    (define (unquote l) (unquote (second binding)))
    ((unquote loopf) (unquote l))
    (unquote l))))

(defmacro (flatten*-mapfor binding . body)
  (quasiquote (flatten* (mapfor (unquote binding) (unquote-splicing body)))))

(defmacro (findfor binding . body)
  (define loopf (gensym))
  (define l (gensym))
  (quasiquote (begin
    (define ((unquote loopf) (unquote l))
      (if (null? (unquote l)) false
          (begin (define (unquote (first binding)) (car (unquote l)))
                 (if (begin (unquote-splicing body)) (unquote (first binding))
                     ((unquote loopf) (cdr (unquote l)))))))
    ((unquote loopf) (unquote (second binding))))))

(defmacro (filterfor binding . body)
  (quasiquote
    (flatten*-mapfor (unquote binding)
      (if (begin (unquote-splicing body))
          (list (unquote (first binding)))
          ()))))

(defmacro (nfilterfor binding . body)
  (define loopf (gensym))
  (define in (gensym))
  (define out (gensym))
  (define out-tail (gensym))
  (quasiquote (begin
     (define (unquote out) (cons () ()))
     (define ((unquote loopf) (unquote in) (unquote out-tail))
       (if (not (null? (unquote in)))
         ((unquote loopf) (cdr (unquote in))
           (if (begin (define (unquote (first binding)) (car (unquote in)))
                      (unquote-splicing body))
               (begin (rplacd (unquote out-tail) (unquote in))
                      (unquote in))
               (unquote out-tail)))
         (rplacd (unquote out-tail) ())))
     ((unquote loopf) (unquote (second binding)) (unquote out))
     (cdr (unquote out)))))

(define (remove item l)
  (cond ((null? l) l)
        ((eq? item (car l)) (remove item (cdr l)))
        (true (cons (car l) (remove item (cdr l))))))

(define (delete item l)
  (define (aux c l)
    (unless (null? l)
      (if (eq? item (car l))
          (begin
            (rplacd c (cdr l))
            (aux c (cdr l)))
          (aux l (cdr l)))))

  (if (null? l) ()
      (if (eq? item (car l))
          (delete item (cdr l))
          (begin
            (aux l (cdr l))
            l))))

(define (sort l pred)
  (if (null? l) l
      (begin
        (define pivot (car l))
        (nconc (sort (filterfor (x (cdr l)) (pred x pivot)) pred)
               (list pivot)
               (sort (filterfor (x (cdr l)) (not (pred x pivot))) pred)))))

(define (reverse l)
  (define (aux acc l)
    (if (null? l) acc
        (aux (cons (car l) acc) (cdr l))))
  (aux () l))

(define (sublist l start . end)
  (if (null? end) (copy-list (nthcdr start l))
      (begin
        (define (copy-partial-list l len)
          (cond ((= 0 len) ())
                ((not (null? l))
                 (cons (car l) (copy-partial-list (cdr l) (1- len))))
                (true
                 (error "sublist fell off the end of the list"))))
        (copy-partial-list (nthcdr start l) (- (first end) start)))))

(define (position x l)
  (define (aux n l)
    (cond ((null? l) false)
          ((eq? x (car l)) n)
          (true (aux (1+ n) (cdr l)))))
  (aux 0 l))

;;; Numbers again

;; We only support left shifts, because that is all the compiler needs
(define (ash n count)
  (cond ((= count 0) n)
        ((> count 0) (ash (+ n n) (1- count)))
        ((< count 0) (truncate n (ash 1 (- count))))))

(define (mod n div)
  (define r (rem n div))
  (if (>= r 0) r (+ r div)))

(defmacro (max init . nums)
  (reduce init nums (lambda (a b)
                      (define avar (gensym))
                      (define bvar (gensym))
                      (quasiquote (begin
                                    (define (unquote avar) (unquote a))
                                    (define (unquote bvar) (unquote b))
                                    (if (> (unquote avar) (unquote bvar))
                                        (unquote avar)
                                        (unquote bvar)))))))

(define (max$ init nums)
  (reduce init nums (lambda (a b) (max a b))))

(define (max init . nums)
  (max$ init nums))


(defmacro (min init . nums)
  (reduce init nums (lambda (a b)
                      (define avar (gensym))
                      (define bvar (gensym))
                      (quasiquote (begin
                                    (define (unquote avar) (unquote a))
                                    (define (unquote bvar) (unquote b))
                                    (if (< (unquote avar) (unquote bvar))
                                        (unquote avar)
                                        (unquote bvar)))))))

(define (min$ init nums)
  (reduce init nums (lambda (a b) (min a b))))

(define (min init . nums)
  (min$ init nums))


;;; Symbols

(when-compiling
  (define symbol-table false)
  (define symbol-id-counter 0)

  (define (intern str)
    ;; have we constructed the symbol table from the symbol list dumped
    ;; by the compiler yet?
    (unless symbol-table
      (set! symbol-table (make-hashtable string-hash string-equal?))

      (define (add-symbols offset end-offset)
        (when (< offset end-offset)
          (define sym (raw-ref (raw-+ (raw-label "symbols_start")
                                      (fixnum->raw offset))))
          (hashtable-set! symbol-table (symbol-name sym) sym)
          (add-symbols (+ offset (compiler-constant value-size))
                       end-offset)))

      (add-symbols 0 (raw->fixnum (raw-- (raw-label "symbols_end")
                                         (raw-label "symbols_start")))))

    (define res (hashtable-ref symbol-table str))
    (if res res
        (begin
          (define res (raw-make-symbol str
                              (set! symbol-id-counter (1- symbol-id-counter))))
          (hashtable-set! symbol-table str res)
          res))))

;;; Strings

(define (check-string-index str index)
  (define str-len (string-length str))
  (unless (and (>= index 0) (< index str-len))
    (error "string index out of bounds (index: ~A, string length: ~A)"
           index str-len)))

(define (check-string-range str offset len)
  (define str-len (string-length str))
  (unless (and (>= offset 0) (<= (+ offset len) str-len))
    (error "string range out of bounds (offset: ~A, length: ~A, string length: ~A)"
           offset len str-len)))

(define (string-ref str index)
  (check-string-index str index)
  (raw-string-ref str index))

(define (string-set! str index ch)
  (check-string-index str index)
  (raw-string-set! str index ch)
  ch)

(define (string-copy src src-offset dest dest-offset len)
  (check-string-range src src-offset len)
  (check-string-range dest dest-offset len)
  (raw-string-copy src src-offset dest dest-offset len))

;;; Vectors

(define (check-vector-index vec index)
  (unless (and (>= index 0) (< index (vector-length vec)))
    (error "vector index out of bounds (index: ~A, vector length: ~A)"
           index (vector-length vec))))

(define (check-vector-range vec offset len)
  (unless (and (>= offset 0) (<= (+ offset len) (vector-length vec)))
    (error "vector range out of bounds (offset: ~A, length: ~A, vector length ~A)"
           offset len (vector-length vec))))

(define (vector-ref vec index)
  (check-vector-index vec index)
  (raw-vector-ref vec index))

(define (vector-set! vec index val)
  (check-vector-index vec index)
  (raw-vector-set! vec index val)
  val)

(define (vector-copy src src-offset dest dest-offset len)
  (check-vector-range src src-offset len)
  (check-vector-range dest dest-offset len)
  (raw-vector-copy src src-offset dest dest-offset len))

(define (vector-set-range! vec index len val)
  (while (/= len 0)
    (vector-set! vec index val)
    (set! index (1+ index))
    (set! len (1- len))))

(define (make-vector-from-list l)
  (define (copy-list-to-vector l vec pos)
    (unless (null? l)
      (vector-set! vec pos (car l))
      (copy-list-to-vector (cdr l) vec (1+ pos))))

  (define vec (make-vector (length l) false))
  (copy-list-to-vector l vec 0)
  vec)

;;; Lists

(define (assoc key l)
  (cond ((null? l) false)
        ((eq? key (caar l)) (car l))
        (true (assoc key (cdr l)))))

(defmacro (push el place)
  (quasiquote (set! (unquote place) (cons (unquote el) (unquote place)))))

(define (acons key val tail)
  (cons (cons key val) tail))

;;; Strings

(define (substring str offset len)
  (define newstr (make-string len (code-character 0)))
  (string-copy str offset newstr 0 len)
  newstr)

(define (string-equal? a b)
  (define len (string-length a))
  (and (= (string-length b) len)
       (begin
         (define (compare-chars pos)
           (or (= pos len)
               (and (eq? (string-ref a pos) (string-ref b pos))
                    (compare-chars (1+ pos)))))
         (compare-chars 0))))

(define (string-flatten strs)
  (define pos 0)
  (dolist (str strs)
    (set! pos (+ pos (string-length str))))
  (define res (make-string pos (code-character 0)))
  (set! pos 0)
  (dolist (str strs)
    (string-copy str 0 res pos (string-length str))
    (set! pos (+ pos (string-length str))))
  res)

(define (string-concat . strs)
  (string-flatten strs))

(define (string-range-equal? a astart b bstart len)
  (cond ((= 0 len) true)
        ((or (>= astart (string-length a))
             (>= bstart (string-length b))
             (not (eq? (string-ref a astart) (string-ref b bstart))))
         false)
        (true
         (string-range-equal? a (1+ astart) b (1+ bstart) (1- len)))))

(define (string-search haystack needle start)
  (define len (string-length needle))
  (cond ((> (+ start len) (string-length haystack)) false)
        ((string-range-equal? haystack start needle 0 len) start)
        (true (string-search haystack needle (1+ start)))))

(define (string-replace str old new)
  (define (string-replace-from str start)
    (define pos (string-search str old start))
    (if pos
        (begin
          (define rest (+ pos (string-length old)))
          (define res (string-concat (substring str 0 pos) new
                           (substring str rest (- (string-length str) rest))))
          (string-replace-from res (+ pos (string-length new))))
        str))
  (string-replace-from str 0))

;;; Equality

(define (equal? a b)
  (cond ((pair? a)
         (and (pair? b) (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))
        ((string? a)
         (and (string? b) (string-equal? a b)))
        (true (eq? a b))))

;;; Command line access

(when-compiling
  (define (copy-c-string addr)
    (define (strlen addr)
      (define (aux offset)
          (if (= 0 (raw->fixnum (raw-1-vec-ref addr offset)))
              offset
              (aux (1+ offset))))
      (aux 0))

    (define len (strlen addr))
    (define str (make-string len (code-character 0)))
    (raw-1-copy addr (raw-string-address str 0) len)
    str)

  (define (c-string-array-to-list addr)
    (define (aux index)
        (define str-addr (raw-vec-ref addr index))
      (if (eq? 0 str-addr)
          ()
          (cons (copy-c-string str-addr) (aux (1+ index)))))
    (aux 0))

  (define command-line-args
          (c-string-array-to-list (raw-ref (raw-label "lisp_argv")))))


;;; Entry point function

(define runtime-main-args-base)

(when-interpreting (define (raw-args-base) false))

(define (runtime-main)
  (set! runtime-main-args-base (raw-args-base))
  (main)
  (flush-ostream stdout))

;;; CL compatibility

(defmacro (let* bindings . body)
  (quasiquote (begin
                (unquote-splicing (mapfor (binding bindings)
                                          (if (pair? binding)
                                              (cons 'define binding)
                                              (list 'define binding))))
                (unquote-splicing body))))

(defmacro (labels funcs . body)
  (quasiquote (begin
                (unquote-splicing
                  (mapfor (func funcs)
                    (list* 'define (cons (car func) (cadr func)) (cddr func))))
                (unquote-splicing body))))

(defmacro (defconstant name val)
  (quasiquote (defmacro (unquote name) (unquote val))))

(defmacro (funcall . form) form)
(defmacro (function f) f)

(defmacro (subject-language-boolean bool) bool)
(defmacro (subject-language-symbol-name sym) (list 'symbol-name sym))
(defmacro (subject-language-intern str) (list 'intern str))
(defmacro (string-symbolcase str) str)

;; Not a full destructuring-bind
(defmacro (bind vars values . body)
  (quasiquote
    (apply (lambda (unquote vars) (unquote-splicing body)) (unquote values))))

